<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto"><link rel=stylesheet type=text/css href=https://andymcdgeo.github.io//css/bootstrap.min.css><link rel=stylesheet type=text/css href=https://andymcdgeo.github.io//css/style.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.1.0/css/solid.css integrity=sha384-TbilV5Lbhlwdyc4RuIV/JhD8NR+BfMrvz4BL5QFa2we1hQu6wvREr3v6XSRfCTRp crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.1.0/css/brands.css integrity=sha384-7xAnn7Zm3QC1jFjVc1A6v/toepoG3JXboQYzbM0jrPzou9OFXm/fY6Z/XiIebl/k crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.1.0/css/fontawesome.css integrity=sha384-ozJwkrqb90Oa3ZNb+yKFW2lToAWYdTiF1vt8JiH5ptTGHTGcN7qdoR1F95e0kYyG crossorigin=anonymous><title>Andy McDonald | Porosity-Permeability Relationships Using Linear Regression in Python</title><meta property="og:title" content="Porosity-Permeability Relationships Using Linear Regression in Python"><meta property="og:description" content="Once data has been collated and sorted through, the next step in the Data Science process is to carry out Exploratory Data Analysis (EDA). This step allows us to identify patterns within the data, understand relationships between the features (well logs) and identify possible outliers that may exist within the dataset."><meta property="og:type" content="article"><meta property="og:url" content="https://andymcdgeo.github.io/blog/2020-11-01-exploratory-data-analysis-with-well-log-data/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-11-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-01T00:00:00+00:00"><meta property="og:site_name" content="Andy McDonald"><meta name=twitter:card content="summary"><meta name=twitter:title content="Porosity-Permeability Relationships Using Linear Regression in Python"><meta name=twitter:description content="Once data has been collated and sorted through, the next step in the Data Science process is to carry out Exploratory Data Analysis (EDA). This step allows us to identify patterns within the data, understand relationships between the features (well logs) and identify possible outliers that may exist within the dataset."></head><body><div class=wrapper><nav class=sidebar><div class=sidebar-content><a href=https://andymcdgeo.github.io/ class=sbar-title><h1>Andy McDonald</h1></a><div class=authorimage><div class=author-image><img src=https://andymcdgeo.github.io/img/andy.png alt="Author Image" class="img--circle img--headshot element--center"></div></div><div class=menu-content><div><ul class=sidebar-nav><li><a href=/about/><span>About</span></a></li><li><a href=/blog/><span>Blog</span></a></li><li><a href=/projects/><span>Publications</span></a></li><li><a href=/projects/><span>Talks</span></a></li></ul></div><section class=social><a href=https://twitter.com/geoandymcd rel=me><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a>
<a href=https://github.com/andymcdgeo rel=me><i class="fab fa-github fa-lg" aria-hidden=true></i></a>
<a href=https://linkedin.com/in/ndymcdonaldgeo rel=me><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a>
<a href=https://medium.com/@andymcdonaldgeo rel=me><i class="fab fa-medium fa-lg" aria-hidden=true></i></a>
<a href=https://www.researchgate.net/profile/Andrew-Mcdonald-15 rel=me><i class="fab fa-researchgate fa-lg" aria-hidden=true></i></a>
<a href=mailto:your-email@example.com rel=me><i class="fas fa-at fa-lg" aria-hidden=true></i></a></section></div></div></nav><div class=content><h1>Porosity-Permeability Relationships Using Linear Regression in Python</h1><figure><img src=/images/featured/2020-11-01-%20EDA%20of%20Well%20Log%20Data.jpg alt="Porosity-Permeability Relationships Using Linear Regression in Python" class=img-fluid></figure><i class="fa fa-calendar"></i>
<time datetime=2020-11-01>Nov 1, 2020</time>
<i class="fa fa-tags"></i>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://andymcdgeo.github.io/tags/petrophysics>petrophysics</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://andymcdgeo.github.io/tags/python>python</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://andymcdgeo.github.io/tags/porosity>porosity</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://andymcdgeo.github.io/tags/permeability>permeability</a>
<a class="btn btn-sm btn-outline-dark tag-btn" href=https://andymcdgeo.github.io/tags/crossplots>crossplots</a><br><br><div class=post-content><p>Once data has been collated and sorted through, the next step in the Data Science process is to carry out Exploratory Data Analysis (EDA). This step allows us to identify patterns within the data, understand relationships between the features (well logs) and identify possible outliers that may exist within the dataset. In this stage, we gain an understanding about the data and check whether further processing is required or if cleaning is necessary.</p><p>As petrophysicists/geoscientists we commonly use log plots, histograms and crossplots (scatter plots) to analyse and explore well log data. Python provides a great toolset for visualising the data from different perspectives in a quick and easy way.</p><p>In this article we will use a subset of the dataset that was released by <a href=https://xeek.ai/challenges/force-well-logs/overview>Xeek</a> and <a href=https://www.npd.no/en/force/events/>FORCE</a> as part of a competition to predict facies from well logs. We will be visualising the data using a mixture of <a href=https://matplotlib.org/>matplotlib</a>, <a href=https://seaborn.pydata.org/>seaborn </a>and <a href=https://github.com/ResidentMario/missingno>missingno</a> data visualisation libraries.</p><p>The visualisations we will cover will allow us to:</p><ul><li><p>Identify where we have or donâ€™t have data</p></li><li><p>Understand the data distribution</p></li><li><p>Visualise data affected by bad hole conditions</p></li></ul><p>The notebook for this article can be found on my Python and Petrophysics Github series which can accessed at the link below:</p><p><a href=https://github.com/andymcdgeo/Petrophysics-Python-Series>https://github.com/andymcdgeo/Petrophysics-Python-Series</a></p><h2 id=loading-the-data-and-libraries>Loading the Data and Libraries</h2><p>The first step for any project is loading the required libraries and data.</p><p>For this workthrough, we are going to call upon a number of plotting libraries: seaborn, matplotlib and missingno as well as math, pandas, and numpy.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#f92672>import</span> pandas <span style=color:#f92672>as</span> pd
    <span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#f92672>as</span> plt
    <span style=color:#f92672>import</span> seaborn <span style=color:#f92672>as</span> sns
    <span style=color:#f92672>import</span> math
    <span style=color:#f92672>import</span> missingno <span style=color:#f92672>as</span> msno
    <span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
</code></pre></div><p>The dataset we are using forms part of a Machine Learning competition run by Xeek and FORCE (<a href=https://xeek.ai/challenges/force-well-logs/overview>https://xeek.ai/challenges/force-well-logs/overview</a>). The objective of the competition was to predict lithology from a dataset consisting 98 training wells each with varying degrees of log completeness. The objective was to predict lithofacies based on the log measurements.</p><p>In order to keep the plots and data manageable in this article I have used a subset of 12 wells from the training data. The data has already been collated into a single csv file with no need to worry about curve mnemonics. To load the subset of data in we can call upon pd.read_csv.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    data <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(<span style=color:#e6db74>&#39;Data/xeek_train_subset.csv&#39;</span>)
</code></pre></div><p>Once the data has been loaded, we can confirm the number and names of the wells using the following commands:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#75715e># Counts the number of unique values in the WELL column</span>
    data[<span style=color:#e6db74>&#39;WELL&#39;</span>]<span style=color:#f92672>.</span>nunique()
</code></pre></div><p>Which will return 12 as expected.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#75715e># Gets the unique names from the WELL column</span>
    data[<span style=color:#e6db74>&#39;WELL&#39;</span>]<span style=color:#f92672>.</span>unique()
</code></pre></div><p>This returns an array object with the well names.</p><pre><code>    array(['15/9-13', '15/9-15', '15/9-17', '16/1-2', '16/1-6 A', '16/10-1', '16/10-2', '16/10-3', '16/10-5', '16/11-1 ST3', '16/2-11 A', '16/2-16'], dtype=object)
</code></pre><h2 id=identifying-gaps>Identifying Gaps</h2><p>Missing data within well logging can arise for a number of reasons including:</p><ul><li><p>Tool failures & problems</p></li><li><p>Missing by choice (i.e. tools not run due to budgetary constraints)</p></li><li><p>Human error</p></li><li><p>Vintage datasets</p></li><li><p>Issues arising from the borehole environment</p></li></ul><p>There are a number of ways that we can use to identify where we have data and where we donâ€™t. We will look at 2 ways to visualise missing data.</p><h3 id=missingno-library>missingno Library</h3><p>The first method we will look at is using the missingno library, which provides a nice little toolbox, created by Aleksy Bilgour, as a way to visualise and understand data completeness. More details on the library can be found at <a href=https://github.com/ResidentMario/missingno>https://github.com/ResidentMario/missingno</a>. If you donâ€™t have this library, you can quickly install it using pip install missingno into your terminal.</p><p>The missingno toolbox contains a number of different visualisations, but for this article we will focus on the matrix plot and bar plot. The matrix plot can be called by:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    msno<span style=color:#f92672>.</span>matrix(data)
</code></pre></div><p><img src=https://cdn-images-1.medium.com/max/15000/1*jGPlyAzKCxAQ3XXMdbYXjA.png alt="import matplotlib.pyplot as plt"></p><p>This shows us the data density across all of the features (log curves). Over on the right hand side of the figure we have sparkline, which illustrates where we have maximum or minimum nullity in the data.</p><p>From the visualisation we can can see that only a handful of columns are complete WELL, DEPTH_MD, GR, GROUP, LITHOFACIES_LITHOLOGY and LITHOFACIES_CONFIDENCE.</p><p>Others have near full data values such DTC, CALI, and ROP, whereas some have very poor data coverage such as RMIC, SGR and ROPA.</p><p>We can also call upon msno.bar(data) to generate a bar chart showing the amount of non-null data values within each column (log curve). Along the top of the chart, we get a total count of the non-null data values.</p><p><img src=https://cdn-images-1.medium.com/max/14400/1*sXC4n3L_ImUFpgASq9uQ5Q.png alt="Missing value counts from msno.bar(data)."></p><p>With a quick glance at the matrix plot and bar chart, you can get a sense of what data is missing from your dataset, especially if you have a large number of columns in your dataset.</p><h3 id=missing-data-visualisation-using-matplotlib>Missing Data Visualisation Using Matplotlib</h3><p>In my previous article: <a href=https://towardsdatascience.com/visualising-well-data-coverage-using-matplotlib-f30591c89754>Visualising Well Data Coverage Using Matplotlib</a> I covered a method of viewing the data coverage on a well by well basis. This allows you to see where the gaps are in your key curves.</p><p>If we wanted to generate a plot for all of the curves per well we could save each one out as a file or present the data in a single column. In this example, I have only selected common curves that a petrophysicist may use in an interpretation.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    data_nan <span style=color:#f92672>=</span> data[[<span style=color:#e6db74>&#39;WELL&#39;</span>,<span style=color:#e6db74>&#39;DEPTH_MD&#39;</span>,<span style=color:#e6db74>&#39;CALI&#39;</span>, <span style=color:#e6db74>&#39;BS&#39;</span>, <span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;PEF&#39;</span>, <span style=color:#e6db74>&#39;RDEP&#39;</span>, <span style=color:#e6db74>&#39;RMED&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>, <span style=color:#e6db74>&#39;DTS&#39;</span>]]<span style=color:#f92672>.</span>copy()
    <span style=color:#66d9ef>for</span> num, col <span style=color:#f92672>in</span> enumerate(data_nan<span style=color:#f92672>.</span>columns[<span style=color:#ae81ff>2</span>:]):
        data_nan[col] <span style=color:#f92672>=</span> data_nan[col]<span style=color:#f92672>.</span>notnull() <span style=color:#f92672>*</span> (num <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
        data_nan[col]<span style=color:#f92672>.</span>replace(<span style=color:#ae81ff>0</span>, num, inplace<span style=color:#f92672>=</span>True)
        <span style=color:#66d9ef>print</span>(col, num) <span style=color:#75715e>#Print out the col name and number to verify it works</span>
    grouped <span style=color:#f92672>=</span> data_nan<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#39;WELL&#39;</span>)

    <span style=color:#75715e>#Setup the labels we want to display on the x-axis</span>
    labels <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;CALI&#39;</span>, <span style=color:#e6db74>&#39;BS&#39;</span>, <span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;PEF&#39;</span>, <span style=color:#e6db74>&#39;RDEP&#39;</span>, <span style=color:#e6db74>&#39;RMED&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>, <span style=color:#e6db74>&#39;DTS&#39;</span>]

    <span style=color:#75715e>#Setup the figure and the subplots</span>
    fig, axs <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>20</span>))

    <span style=color:#75715e>#Loop through each well and column in the grouped dataframe</span>
    <span style=color:#66d9ef>for</span> (name, df), ax <span style=color:#f92672>in</span> zip(grouped, axs<span style=color:#f92672>.</span>flat):
        ax<span style=color:#f92672>.</span>set_xlim(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>9</span>)
        
        <span style=color:#75715e>#Setup the depth range</span>
        ax<span style=color:#f92672>.</span>set_ylim(<span style=color:#ae81ff>5000</span>, <span style=color:#ae81ff>0</span>)
        
        <span style=color:#75715e>#Create multiple fill betweens for each curve# This is between</span>
        <span style=color:#75715e># the number representing null values and the number representing</span>
        <span style=color:#75715e># actual values</span>
        
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>0</span>, df<span style=color:#f92672>.</span>CALI, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;grey&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>1</span>, df<span style=color:#f92672>.</span>BS, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;lightgrey&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>2</span>, df<span style=color:#f92672>.</span>GR, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mediumseagreen&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>3</span>, df<span style=color:#f92672>.</span>NPHI, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;lightblue&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>4</span>, df<span style=color:#f92672>.</span>RHOB, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;lightcoral&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>5</span>, df<span style=color:#f92672>.</span>PEF, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;violet&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>6</span>, df<span style=color:#f92672>.</span>RDEP, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;darksalmon&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>7</span>, df<span style=color:#f92672>.</span>RMED, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;wheat&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>8</span>, df<span style=color:#f92672>.</span>DTC, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;thistle&#39;</span>)
        ax<span style=color:#f92672>.</span>fill_betweenx(df<span style=color:#f92672>.</span>DEPTH_MD, <span style=color:#ae81ff>9</span>, df<span style=color:#f92672>.</span>DTS, facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;tan&#39;</span>)
        
        <span style=color:#75715e>#Setup the grid, axis labels and ticks</span>
        ax<span style=color:#f92672>.</span>grid(axis<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;x&#39;</span>, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.5</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;black&#39;</span>)
        ax<span style=color:#f92672>.</span>set_ylabel(<span style=color:#e6db74>&#39;DEPTH (m)&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>, fontweight<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bold&#39;</span>)
        
        <span style=color:#75715e>#Position vertical lines at the boundaries between the bars</span>
        ax<span style=color:#f92672>.</span>set_xticks([<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>10</span>], minor<span style=color:#f92672>=</span>False)
        
        <span style=color:#75715e>#Position the curve names in the centre of each column</span>
        ax<span style=color:#f92672>.</span>set_xticks([<span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>1.5</span> ,<span style=color:#ae81ff>2.5</span> ,<span style=color:#ae81ff>3.5</span> ,<span style=color:#ae81ff>4.5</span> ,<span style=color:#ae81ff>5.5</span> ,<span style=color:#ae81ff>6.5</span> , <span style=color:#ae81ff>7.5</span>, <span style=color:#ae81ff>8.5</span>, <span style=color:#ae81ff>9.5</span>], minor<span style=color:#f92672>=</span>True)
        
        <span style=color:#75715e>#Setup the x-axis tick labels</span>
        ax<span style=color:#f92672>.</span>set_xticklabels(labels,  rotation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;vertical&#39;</span>, minor<span style=color:#f92672>=</span>True, verticalalignment<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bottom&#39;</span>)
        ax<span style=color:#f92672>.</span>set_xticklabels(<span style=color:#e6db74>&#39;&#39;</span>, minor<span style=color:#f92672>=</span>False)
        ax<span style=color:#f92672>.</span>tick_params(axis<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;x&#39;</span>, which<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;minor&#39;</span>, pad<span style=color:#f92672>=-</span><span style=color:#ae81ff>10</span>)
        
        <span style=color:#75715e>#Assign the well name as the title to each subplot</span>
        ax<span style=color:#f92672>.</span>set_title(name, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>16</span>, fontweight<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bold&#39;</span>)

    plt<span style=color:#f92672>.</span>savefig(<span style=color:#e6db74>&#39;missingdata.png&#39;</span>)
    plt<span style=color:#f92672>.</span>tight_layout()
    plt<span style=color:#f92672>.</span>subplots_adjust(hspace<span style=color:#f92672>=</span><span style=color:#ae81ff>0.15</span>, wspace<span style=color:#f92672>=</span><span style=color:#ae81ff>0.25</span>)
    plt<span style=color:#f92672>.</span>show()
</code></pre></div><p><img src=https://cdn-images-1.medium.com/max/12000/1*WFuf60EPHEZMqaPUeHdhBg.png alt="Multi-well plot showing data coverage per well within the dataset."></p><p>From the generated image, we can identify where the gaps are in our main curves. From this plot we can determine which wells would be useful to carry forward for machine learning modelling or for further investigation.</p><h2 id=getting-familiar-with-the-data>Getting Familiar With the Data</h2><p>In this section, we will look at a number of visualisations that can be used to gain insight into our data and how that data relations to lithofacies and geological stratigraphy.</p><p>There are multiple plotting and data visualisation libraries with the Python world. One of these is <a href=https://seaborn.pydata.org>Seaborn</a>, which is a data visualisation library built on top of <a href=https://matplotlib.org/>matplotlib</a> and works closely with <a href=https://pandas.pydata.org/>pandas</a>. It provides an easy and more intuitive way to display and explore your data.</p><p>The following examples illustrate a few different plots that can be used to quickly gain insight into your data using a mixture of FacetGrid and matplotlib.</p><h3 id=density--neutron-distribution-by-lithology>Density â€” Neutron Distribution by Lithology</h3><p>FacetGrid provides an easier and smoother way of plotting multiple subplots in a grid using a small amount of code compared to matplotlib.</p><p>Before we can use our data, we first have to convert our numeric lithology data to actual descriptive labels. This is achieved by using a simple dictionary:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    lithology_numbers <span style=color:#f92672>=</span> {<span style=color:#ae81ff>30000</span>: <span style=color:#e6db74>&#39;Sandstone&#39;</span>,
                     <span style=color:#ae81ff>65030</span>: <span style=color:#e6db74>&#39;Sandstone/Shale&#39;</span>,
                     <span style=color:#ae81ff>65000</span>: <span style=color:#e6db74>&#39;Shale&#39;</span>,
                     <span style=color:#ae81ff>80000</span>: <span style=color:#e6db74>&#39;Marl&#39;</span>,
                     <span style=color:#ae81ff>74000</span>: <span style=color:#e6db74>&#39;Dolomite&#39;</span>,
                     <span style=color:#ae81ff>70000</span>: <span style=color:#e6db74>&#39;Limestone&#39;</span>,
                     <span style=color:#ae81ff>70032</span>: <span style=color:#e6db74>&#39;Chalk&#39;</span>,
                     <span style=color:#ae81ff>88000</span>: <span style=color:#e6db74>&#39;Halite&#39;</span>,
                     <span style=color:#ae81ff>86000</span>: <span style=color:#e6db74>&#39;Anhydrite&#39;</span>,
                     <span style=color:#ae81ff>99000</span>: <span style=color:#e6db74>&#39;Tuff&#39;</span>,
                     <span style=color:#ae81ff>90000</span>: <span style=color:#e6db74>&#39;Coal&#39;</span>,
                     <span style=color:#ae81ff>93000</span>: <span style=color:#e6db74>&#39;Basement&#39;</span>}
</code></pre></div><p>In our dataframe, we create a new column called LITH and using the map function we can quickly get our descriptive labels like so:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    data[<span style=color:#e6db74>&#39;LITH&#39;</span>] <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;FORCE_2020_LITHOFACIES_LITHOLOGY&#39;</span>]<span style=color:#f92672>.</span>map(lithology_numbers)
</code></pre></div><p>For the first FacetGrid, we will look at the density-neutron data by formation. When we do this we only need to specify a few lines of code as opposed to multiple lines or using a for loop as seen in the example above with missing data. We can initialise the FacetGrid with the density neutron data and passing the LITH column into the col parameter. Additionally, we can use the col_wrap parameter to specify how many columns we want on our grid.</p><p>Finally, as we are familiar with working with density-neutron data on crossplots using certain scales we need to set the xlim and ylim accordingly, otherwise it will autoscale.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    g <span style=color:#f92672>=</span> sns<span style=color:#f92672>.</span>FacetGrid(data, col<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;LITH&#39;</span>, col_wrap<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
    g<span style=color:#f92672>.</span>map(sns<span style=color:#f92672>.</span>scatterplot, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.5</span>)
    g<span style=color:#f92672>.</span>set(xlim<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.15</span>, <span style=color:#ae81ff>1</span>))
    g<span style=color:#f92672>.</span>set(ylim<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>))
</code></pre></div><p><img src=https://cdn-images-1.medium.com/max/7172/1*1xcVh1H8_wf1PHUCTP78rA.png alt="FacetGrid of density-neutron data split by lithology."></p><p>This will generate a series of mini scatterplots/crossplots of the density-neutron data split by lithology. You can see from the code above, all we had to specify were the type of plot, the axes and setting the axis limits, and from this we have a nice plot we can use right away.</p><h3 id=density--neutron-distribution-by-lithology-and-well>Density â€” Neutron Distribution by Lithology and Well</h3><p>We can further enhance the density neutron data by looking at the lithology distribution across multiple wells. Using the converted LITH data column we can create shading for different lithology types by supplying LITH to the hue parameter. We can then supply the WELL column from the dataframe into the col parameter.</p><p>The marker can be changed by supplying a value to the marker and size parameters. This will help clean up the plots so we can see more of the data.</p><p>Finally, as we are using a hue, we can automatically generate a legend using add_legend().</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    g <span style=color:#f92672>=</span> sns<span style=color:#f92672>.</span>FacetGrid(data, col<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;WELL&#39;</span>, hue<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;LITH&#39;</span>, col_wrap<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
    g<span style=color:#f92672>.</span>map(sns<span style=color:#f92672>.</span>scatterplot, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, linewidth<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, size<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>, marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;+&#39;</span>)
    g<span style=color:#f92672>.</span>set(xlim<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.15</span>, <span style=color:#ae81ff>1</span>))
    g<span style=color:#f92672>.</span>set(ylim<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>))
    g<span style=color:#f92672>.</span>add_legend()
</code></pre></div><p><img src=https://cdn-images-1.medium.com/max/8120/1*IhIiscG1fJfxed5OhV6O3g.png alt="FacetGrid of density-neutron data split by well and coloured by lithology."></p><h3 id=density--neutron-distribution-by-lithology-and-geological-group>Density â€” Neutron Distribution by Lithology and Geological Group</h3><p>We can easily swap out the grouping option for the geological GROUP column to view the lithology variation by group.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    g <span style=color:#f92672>=</span> sns<span style=color:#f92672>.</span>FacetGrid(data, col<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;GROUP&#39;</span>, hue<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;LITH&#39;</span>, col_wrap<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
    g<span style=color:#f92672>.</span>map(sns<span style=color:#f92672>.</span>scatterplot, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, linewidth<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, size<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>, marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;+&#39;</span>)
    g<span style=color:#f92672>.</span>set(xlim<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.15</span>, <span style=color:#ae81ff>1</span>))
    g<span style=color:#f92672>.</span>set(ylim<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>))
    g<span style=color:#f92672>.</span>add_legend()
</code></pre></div><p><img src=https://cdn-images-1.medium.com/max/8120/1*ilv7KNYjWNxPKLDHVW8New.png alt="FacetGrid of density-neutron data split by geological group and coloured by lithology"></p><p>From this chart, we can quickly see that the Rotliegendes Gp is primarily sandstone and that the Nordaland Gp is a mixture of Shale and Sandstone/Shale lithologies.</p><h3 id=the-seaborn-pairplot>The Seaborn PairPlot</h3><p>The Seaborn library also has a very powerful visualisation known as a pairplot which can be called through a single line of code. This allows us to compare, on a grid, multiple columns/measurements against each other. The equivalent code in matplotlib would extend several lines.</p><p>Prior to displaying the pairplot we need to modify the data we are using. Firstly, we will work with a subset of the data consisting of some commonly used well logs. If we used all of the columns in the example for this article, we would be unable to view the details. Secondly, we need to drop any missing data values, otherwise issues can arise when plotting.</p><p>To create a list of the curves we want:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    key_logs <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;CALI&#39;</span>, <span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;PEF&#39;</span>, <span style=color:#e6db74>&#39;RDEP&#39;</span>, <span style=color:#e6db74>&#39;RMED&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>, <span style=color:#e6db74>&#39;DTS&#39;</span>]
</code></pre></div><p>We can then take a subset of our data:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    subset <span style=color:#f92672>=</span> data[key_logs]
    subset <span style=color:#f92672>=</span> subset<span style=color:#f92672>.</span>dropna()
</code></pre></div><p>Once we have the list of key curves we can pass it in to the vars argument in the pair plot.</p><pre><code>sns.pairplot(subset, vars=key_logs, diag_kind='hist', plot_kws={'alpha':0.6, 'edgecolor':'k'})
</code></pre><p><img src=https://cdn-images-1.medium.com/max/13456/1*9MPcjELmeaQqAf-XZOpzzQ.png alt="Pairplot of our well data. Histograms are along the diagonal for the distribution of each log curve."></p><p>This produces multiple scatter plots with a histogram of each of the curves along the diagonal. As you can see this allows us to quickly understand how data is distributed and correlated between the different logging curves. A very powerful plot!</p><h2 id=identifying-bad-hole-data>Identifying Bad Hole Data</h2><p>In this section we will briefly look at a way to visualise where we have badhole data caused by borehole enlargement. Deterioration of the borehole wall can happen for a number of different reasons including undercompacted rocks and variations in stresses acting on those rocks such as variations in mud weight.</p><p>As identified in the missing data section only 10 of our wells have a bitsize curve. Therefore, 2 wells will not be plotted. We can use the bitsize curve alongside the caliper curve to create a difference caliper. Negative numbers indicate the borehole has shrunk in size (e.g. shale swelling) and positive numbers indicate the borehole has increased in size.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    data[<span style=color:#e6db74>&#39;DIF_CAL&#39;</span>] <span style=color:#f92672>=</span> data[<span style=color:#e6db74>&#39;CALI&#39;</span>] <span style=color:#f92672>-</span> data[<span style=color:#e6db74>&#39;BS&#39;</span>]
</code></pre></div><p>As we will be using matplotlib for these plots we first need to group the dataframe by WELL:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    grouped <span style=color:#f92672>=</span> data<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#39;WELL&#39;</span>)
</code></pre></div><p>Then calculate the number of rows we need for our plot:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    nrows <span style=color:#f92672>=</span> int(math<span style=color:#f92672>.</span>ceil(len(grouped)<span style=color:#f92672>/</span><span style=color:#ae81ff>3.</span>))
</code></pre></div><p>Finally, we can use a small for loop to go through each well and add a subplot of density vs neutron to our figure. The c argument in df.plot allows us to specify a column in our dataframe to colour the data. In this case we will use the DIF_CAL data we calculated.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    fig, axs <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(nrows, <span style=color:#ae81ff>3</span>, figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>20</span>))
    <span style=color:#66d9ef>for</span> (name, df), ax <span style=color:#f92672>in</span> zip(grouped, axs<span style=color:#f92672>.</span>flat):
        df<span style=color:#f92672>.</span>plot(kind<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;scatter&#39;</span>, x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;NPHI&#39;</span>, y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;RHOB&#39;</span>, ax<span style=color:#f92672>=</span>ax, c<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;DIF_CAL&#39;</span>, cmap<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;jet&#39;</span>, vmin<span style=color:#f92672>=-</span><span style=color:#ae81ff>1</span>, vmax<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>)
        ax<span style=color:#f92672>.</span>set_xlim(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.15</span>,<span style=color:#ae81ff>1</span>)
        ax<span style=color:#f92672>.</span>set_ylim(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>1</span>)
        ax<span style=color:#f92672>.</span>set_title(name)
    plt<span style=color:#f92672>.</span>tight_layout()
</code></pre></div><p><img src=https://cdn-images-1.medium.com/max/2836/1*3sSSSxrSGEEerlD__AcWNQ.png alt="Multi-well plot of the density-neutron log data coloured by a calculated difference caliper curve."></p><p>From a quick glance we can see that we may have issues with the data in two of the wells: 15/9â€“15 and 16/1â€“2. These should then be investigated further.</p><p>We can also apply the same idea to our lithologies. If we find that a lithology is badly affected by badhole conditions, there could be potential consequences when attempting to predict that lithology using machine learning algorithms.</p><p>To do this, we group the data by LITH and use the same plotting logic as above.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#75715e># Determine number of rows</span>
    nrows <span style=color:#f92672>=</span> int(math<span style=color:#f92672>.</span>ceil(len(grouped)<span style=color:#f92672>/</span><span style=color:#ae81ff>3.</span>))

    <span style=color:#75715e># Group our data</span>
    grouped_lith <span style=color:#f92672>=</span> data<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#39;LITH&#39;</span>)

    <span style=color:#75715e># Plot our data</span>
    fig, axs <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(nrows, <span style=color:#ae81ff>3</span>, figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>20</span>))
    <span style=color:#66d9ef>for</span> (name, df), ax <span style=color:#f92672>in</span> zip(grouped_lith, axs<span style=color:#f92672>.</span>flat):
        df<span style=color:#f92672>.</span>plot(kind<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;scatter&#39;</span>, x<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;NPHI&#39;</span>, y<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;RHOB&#39;</span>, c<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;DIF_CAL&#39;</span>, cmap<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;jet&#39;</span>, ax<span style=color:#f92672>=</span>ax, vmin<span style=color:#f92672>=-</span><span style=color:#ae81ff>1</span>, vmax<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>)
        ax<span style=color:#f92672>.</span>set_xlim(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.05</span>,<span style=color:#ae81ff>1</span>)
        ax<span style=color:#f92672>.</span>set_ylim(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>0</span>)
        ax<span style=color:#f92672>.</span>set_title(name)
    plt<span style=color:#f92672>.</span>tight_layout()
</code></pre></div><p><img src=https://cdn-images-1.medium.com/max/2864/1*z5MDyPTqE2W5Fc4ZqmilhA.png alt="Multi-well plot of the density-neutron log data split by lithology and coloured by a calculated difference caliper curve."></p><p>From the plot, we can see that all lithologies have a large degree of â€˜goodâ€™ data in them.</p><h2 id=conclusions>Conclusions</h2><p>In this article, we have covered some of thee ways in which you can explore and visualise well log data using common Python libraries. We have seen how to use Seaborn to quickly plot multiple datasets on single figures and split that data by wells and lithology. We have also seen how to quickly identify missing data and data affected by badhole conditions.</p><p>Exploring your data is a great way to become familiar with it and understand it, especially prior to carrying out machine learning or further interpretation.</p><h2 id=references>References</h2><p>Bormann P., Aursand P., Dilib F., Dischington P., Manral S. 2020. 2020 FORCE Machine Learning Contest. <a href=https://github.com/bolgebrygg/Force-2020-Machine-Learning-competition>https://github.com/bolgebrygg/Force-2020-Machine-Learning-competition</a></p><p>FORCE: Machine Predicted Lithology: <a href=https://xeek.ai/challenges/force-well-logs/overview>https://xeek.ai/challenges/force-well-logs/overview</a></p></div><div id=disqus_thread></div><script type=text/javascript>(function(){var a,b;if(location.hostname==="localhost"||location.hostname==="127.0.0.1"||location.hostname==="")return;a=document.createElement('script'),a.type='text/javascript',a.async=!0,b='andymcdonald-scot.disqus.com',a.src='//'+b+'.disqus.com/embed.js',(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(a)})()</script><noscript>Please enable JavaScript to view the
<a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by
<span class=logo-disqus>Disqus</span></a></div></div></div></body></html>