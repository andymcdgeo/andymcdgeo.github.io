<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"http://schema.org","@type":"Website","@id":"https:\/\/www.andymcdonald.scot\/","author":{"@type":"Person","name":"Andy McDonald","image":"https://www.andymcdonald.scot/images/andy2.png"},"name":"Andy McDonald","description":"See how to use Python and Unsupervised Machine Learning to identify facies from well log data.","url":"https:\/\/www.andymcdonald.scot\/blog\/2021\/2021-06-02-unsupervised-clustering-of-facies\/","keywords":"[]"}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.98.0 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Andy McDonald"><meta name=keywords content><meta name=description content="See how to use Python and Unsupervised Machine Learning to identify facies from well log data."><meta property="og:description" content="See how to use Python and Unsupervised Machine Learning to identify facies from well log data."><meta property="og:type" content="article"><meta property="og:title" content="How to Use Unsupervised Clustering on Well Log Data"><meta name=twitter:title content="How to Use Unsupervised Clustering on Well Log Data"><meta property="og:url" content="https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/"><meta property="twitter:url" content="https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/"><meta property="og:site_name" content="Andy McDonald"><meta property="og:description" content="See how to use Python and Unsupervised Machine Learning to identify facies from well log data."><meta name=twitter:description content="See how to use Python and Unsupervised Machine Learning to identify facies from well log data."><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2021-06-02T00:00:00"><meta property="article:modified_time" content="2021-06-02T00:00:00"><meta property="article:section" content="Petrophysics"><meta property="article:section" content="Python"><meta property="article:section" content="LAS"><meta property="article:tag" content="petrophysics"><meta property="article:tag" content="python"><meta property="article:tag" content="matplotlib"><meta property="article:tag" content="lasio"><meta name=twitter:card content="summary"><meta property="og:image" content="https://www.andymcdonald.scot/images/andy2.png"><meta property="twitter:image" content="https://www.andymcdonald.scot/images/andy2.png"><title>How to Use Unsupervised Clustering on Well Log Data</title><link rel=icon href=https://www.andymcdonald.scot/favicon.png><link rel=canonical href=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://www.andymcdonald.scot/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css></head><body><div id=blog><header id=header data-behavior=2><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://www.andymcdonald.scot/ aria-label="Go to homepage">Andy McDonald</a></div><a class=header-right-picture href=https://www.andymcdonald.scot/#about aria-label="Open the link: /#about"><img class=header-picture src=https://www.andymcdonald.scot/images/andy2.png alt="Author's picture"></a></header><nav id=sidebar data-behavior=2><div class=sidebar-container><div class=sidebar-profile><a href=https://www.andymcdonald.scot/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://www.andymcdonald.scot/images/andy2.png alt="Author's picture"></a><h4 class=sidebar-profile-name>Andy McDonald</h4><h5 class=sidebar-profile-bio>Super bio with markdown support <strong>COOL</strong></h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://www.andymcdonald.scot/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://www.andymcdonald.scot/about title=About><i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden=true></i>
<span class=sidebar-button-desc>About</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://www.andymcdonald.scot/blog title=Blog><i class="sidebar-button-icon fas fa-lg fa-server" aria-hidden=true></i>
<span class=sidebar-button-desc>Blog</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://www.andymcdonald.scot/published_work title=Publications><i class="sidebar-button-icon fas fa-lg fa-book" aria-hidden=true></i>
<span class=sidebar-button-desc>Publications</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://www.andymcdonald.scot/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://www.andymcdonald.scot/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/andymcdgeo target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://www.linkedin.com/in/andymcdonaldgeo/ target=_blank rel=noopener title=LinkedIn><i class="sidebar-button-icon fab fa-lg fa-linkedin" aria-hidden=true></i>
<span class=sidebar-button-desc>LinkedIn</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://medium.com/@andymcdonaldgeo target=_blank rel=noopener title=Medium><i class="sidebar-button-icon fab fa-lg fa-medium" aria-hidden=true></i>
<span class=sidebar-button-desc>Medium</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://www.youtube.com/c/AndyMcDonald42 target=_blank rel=noopener title=YouTube><i class="sidebar-button-icon fab fa-lg fa-youtube" aria-hidden=true></i>
<span class=sidebar-button-desc>YouTube</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://www.andymcdonald.scot/index.xml title=RSS><i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden=true></i>
<span class=sidebar-button-desc>RSS</span></a></li></ul></div></nav><div id=main data-behavior=2 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>How to Use Unsupervised Clustering on Well Log Data</h1><div class="postShorten-meta post-meta"><time datetime=2021-06-02T00:00:00Z>June 2, 2021</time>
<span>in</span>
<a class=category-link href=https://www.andymcdonald.scot/categories/petrophysics>Petrophysics</a>,
<a class=category-link href=https://www.andymcdonald.scot/categories/python>Python</a>,
<a class=category-link href=https://www.andymcdonald.scot/categories/las>LAS</a></div></div><div class="post-content markdown"><div class=main-content-wrap><p>Understanding the subsurface lithology is an important task in geoscience and petrophysics. Using a variety of electrical measurements generated from well logging technology we are able to make inferences about the underlying geology, such as the lithology, facies, porosity, and permeability.</p><p>Machine Learning algorithms have routinely been adopted to group well log measurements into distinct lithological groupings, known as facies. This process can be achieved using either unsupervised learning or supervised learning algorithms.</p><p><strong>Supervised learning</strong> is the most common and practical of machine learning tasks and it is designed to learn from example using input data that has been mapped to the &ldquo;correct&rdquo; output. Alternatively, we can run the modelling using <strong>Unsupervised Learning</strong>, where we let the algorithms identify underlying patterns within the data that may not be easily visible during data exploration.</p><p>In this tutorial we will be carrying out unsupervised learning classification using three clustering methods (K Means Clustering, Gaussian Mixture Modelling and DBSCAN) and comparing the results with an established Lithofacies curve.</p><h2 id=what-is-clustering--cluster-analysis>What is Clustering / Cluster Analysis?</h2><p>Clustering of data is a common form of exploratory data analysis (EDA) which is used to divide up the data into different groups based on shared characteristics or properties. Data points that are similar to each other are grouped together in the same cluster, and those that are different are placed in another cluster.</p><h3 id=k-means-clustering>K-Means Clustering</h3><p>K-Means clustering is a very commonly used unsupervised machine learning algorithm. It is used to group data into K number of clusters by minimising the distance between the data point and the centroid.</p><p>The centroid is initialised at k random points in the data space and all points around it are assigned to the relevant cluster based on the distance to the centroid. The centroid is then adjusted to the central point of the cluster and the points surrounding it are reassigned. This continues until either there is no change in the centroids or the points remain in the same cluster or until a maximum number of iterations is reached.</p><p>K-Means is a hard clustering method where a data point either belongs to a cluster or it does not. It also carries out clustering by applying a circle (or hyper-sphere in multi-dimensional datasets)to the data.</p><h3 id=gaussian-mixture-modelling>Gaussian Mixture Modelling</h3><p>The GMM method also allows data points to be clustered, except that it accounts for data variance, results in a softer classification and rather than being distance based it is distribution based.</p><p>Also, the data point being classified has a probability of being one cluster or another.</p><p>While K-Means clustering works great if the data clusters are circular, however, in petrophysical and geological situations data rarely forms nice circular patterns. GMM modelling uses eliptical shaped cluster/decision boundaries and are therefore more flexible.</p><p>An excellent article looking at the differences between the two methods can be found at <a href=https://www.analyticsvidhya.com/blog/2019/10/gaussian-mixture-models-clustering/>https://www.analyticsvidhya.com/blog/2019/10/gaussian-mixture-models-clustering/</a></p><h2 id=dataset>Dataset</h2><p>The dataset we are using for this tutorial forms part of a Machine Learning competition run by Xeek and FORCE 2020 (<a href=https://doi.org/10.5281/zenodo.4351155)>https://doi.org/10.5281/zenodo.4351155)</a>. The objective of the compettion was to predict lithology from existing labelled data. The dataset consists of 118 wells from the Norwegian Sea.</p><h2 id=importing-libraries--data-loading>Importing Libraries & Data Loading</h2><p>The first step of the project is to import the libraries that we require. For this example we will be using <a href=https://numpy.org>NumPy</a> for working with arrays, <a href=https://pandas.pydata.org>pandas</a> for storing data, <a href=https://seaborn.pydata.org>seaborn</a> and <a href=https://matplotlib.org>matplotlib</a> for displaying the data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> seaborn <span style=color:#66d9ef>as</span> sns
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.colors <span style=color:#66d9ef>as</span> colors
</span></span></code></pre></div><p>We will then read in the data using <code>pd.read_csv</code> and then view the first five rows using the <code>head()</code> method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(<span style=color:#e6db74>&#34;Data/xeek_train_subset.csv&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df<span style=color:#f92672>.</span>describe()
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_5_0.png alt=png></p><p>As it is quite a big table, we can view the columns by calling upon <code>df.columns</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df<span style=color:#f92672>.</span>columns
</span></span></code></pre></div><pre><code>Index(['WELL', 'DEPTH_MD', 'X_LOC', 'Y_LOC', 'Z_LOC', 'GROUP', 'FORMATION',
       'CALI', 'RSHA', 'RMED', 'RDEP', 'RHOB', 'GR', 'SGR', 'NPHI', 'PEF',
       'DTC', 'SP', 'BS', 'ROP', 'DTS', 'DCAL', 'DRHO', 'MUDWEIGHT', 'RMIC',
       'ROPA', 'RXO', 'FORCE_2020_LITHOFACIES_LITHOLOGY',
       'FORCE_2020_LITHOFACIES_CONFIDENCE'],
      dtype='object')
</code></pre><p>We don&rsquo;t need all of the columns for this example, so we will take a copy of the dataframe with the required logging measurements, including the well name and the depth curve.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf <span style=color:#f92672>=</span> df[[<span style=color:#e6db74>&#34;WELL&#34;</span>, <span style=color:#e6db74>&#34;DEPTH_MD&#34;</span>, <span style=color:#e6db74>&#34;RDEP&#34;</span>, <span style=color:#e6db74>&#34;RHOB&#34;</span>, <span style=color:#e6db74>&#34;GR&#34;</span>, <span style=color:#e6db74>&#34;NPHI&#34;</span>, <span style=color:#e6db74>&#34;PEF&#34;</span>, <span style=color:#e6db74>&#34;DTC&#34;</span>, <span style=color:#e6db74>&#34;FORCE_2020_LITHOFACIES_LITHOLOGY&#34;</span>]]<span style=color:#f92672>.</span>copy()
</span></span></code></pre></div><p>We will also rename the <code>FORCE_2020_LITHOFACIES_LITHOLOGY</code> column to something simpler like <code>FACIES</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf<span style=color:#f92672>.</span>rename(columns<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;FORCE_2020_LITHOFACIES_LITHOLOGY&#39;</span>:<span style=color:#e6db74>&#39;FACIES&#39;</span>}, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_12_0.png alt=png></p><h2 id=column-remapping--renaming>Column Remapping / Renaming</h2><p>To make things simpler with plotting, and understanding what the lithology numbers supplied with the data mean, we can create two dictionaries and map the <code>FACIES</code> column to two new columns.</p><p>The first is creating a dictionary for the string representations of the numbers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>lithology_numbers <span style=color:#f92672>=</span> {<span style=color:#ae81ff>30000</span>: <span style=color:#e6db74>&#39;Sandstone&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>65030</span>: <span style=color:#e6db74>&#39;Sandstone/Shale&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>65000</span>: <span style=color:#e6db74>&#39;Shale&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>80000</span>: <span style=color:#e6db74>&#39;Marl&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>74000</span>: <span style=color:#e6db74>&#39;Dolomite&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>70000</span>: <span style=color:#e6db74>&#39;Limestone&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>70032</span>: <span style=color:#e6db74>&#39;Chalk&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>88000</span>: <span style=color:#e6db74>&#39;Halite&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>86000</span>: <span style=color:#e6db74>&#39;Anhydrite&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>99000</span>: <span style=color:#e6db74>&#39;Tuff&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>90000</span>: <span style=color:#e6db74>&#39;Coal&#39;</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>93000</span>: <span style=color:#e6db74>&#39;Basement&#39;</span>}
</span></span></code></pre></div><p>The second dictionary is simplifying the lithology number to range from 1 to 12 instead of the large range of numbers used in the original data. This will help when it comes to making a log plot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>simple_lithology_numbers <span style=color:#f92672>=</span> {<span style=color:#ae81ff>30000</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>65030</span>: <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>65000</span>: <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>80000</span>: <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>74000</span>: <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>70000</span>: <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>70032</span>: <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>88000</span>: <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>86000</span>: <span style=color:#ae81ff>9</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>99000</span>: <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>90000</span>: <span style=color:#ae81ff>11</span>,
</span></span><span style=display:flex><span>                 <span style=color:#ae81ff>93000</span>: <span style=color:#ae81ff>12</span>}
</span></span></code></pre></div><p>To create new columns in our dataframe, we start with defining the column name <code>workingdf['LITH']</code> and then we assign the mapped values using the <code>.map()</code> method.</p><p>We do this for both the string and simple number representations of the facies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf[<span style=color:#e6db74>&#39;LITH&#39;</span>] <span style=color:#f92672>=</span> workingdf[<span style=color:#e6db74>&#39;FACIES&#39;</span>]<span style=color:#f92672>.</span>map(lithology_numbers)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf[<span style=color:#e6db74>&#39;LITH_SI&#39;</span>] <span style=color:#f92672>=</span> workingdf[<span style=color:#e6db74>&#39;FACIES&#39;</span>]<span style=color:#f92672>.</span>map(simple_lithology_numbers)
</span></span></code></pre></div><p>When we view the dataframe, we can see that we now have our two new columns at the end.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_22_0.png alt=png></p><h2 id=visualising-the-data>Visualising the Data</h2><p>As there is already a FACIES column with this data, we can take a quick look to see how the data is distributed across each lithofacies.</p><p>To do this we can use Seaborn&rsquo;s <code>FacetGrid</code> method to plot individual density-neutron crossplots (scatterplots) for each lithology.</p><p>The FacetGrid is used to create an underlying structure for the plot. In this example, the FacetGrid has been passed the dataframe we are working with (<code>workingdf</code>), the column we want to split the plots up by (<code>col</code>) and the point at which we want to wrap to a new row (<code>col_wrap</code>). In this instance, once there are 4 columns, then the data will wrap.</p><p>We can then map a density neutron crossplot ontop of that <code>FacetGrid</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>g <span style=color:#f92672>=</span> sns<span style=color:#f92672>.</span>FacetGrid(workingdf, col<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;LITH&#39;</span>, col_wrap<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>g<span style=color:#f92672>.</span>map(sns<span style=color:#f92672>.</span>scatterplot, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>g<span style=color:#f92672>.</span>set(xlim<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>0.15</span>, <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>g<span style=color:#f92672>.</span>set(ylim<span style=color:#f92672>=</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_24_1.png alt=png></p><p>Before we plot any data we need to create a few functions. The first is a create plot function, which will take a number of arguments and our facies curve, and will generate a conventional log plot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_plot</span>(wellname, dataframe, curves_to_plot, depth_curve, log_curves<span style=color:#f92672>=</span>[], facies_curves<span style=color:#f92672>=</span>[]):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Count the number of tracks we need</span>
</span></span><span style=display:flex><span>    num_tracks <span style=color:#f92672>=</span> len(curves_to_plot)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    facies_color <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;#F4D03F&#39;</span>, <span style=color:#e6db74>&#39;#F5B041&#39;</span>,<span style=color:#e6db74>&#39;#DC7633&#39;</span>,<span style=color:#e6db74>&#39;#6E2C00&#39;</span>, <span style=color:#e6db74>&#39;#1B4F72&#39;</span>,<span style=color:#e6db74>&#39;#2E86C1&#39;</span>, <span style=color:#e6db74>&#39;#AED6F1&#39;</span>, <span style=color:#e6db74>&#39;#A569BD&#39;</span>, <span style=color:#e6db74>&#39;#196F3D&#39;</span>, <span style=color:#e6db74>&#39;red&#39;</span>,<span style=color:#e6db74>&#39;black&#39;</span>, <span style=color:#e6db74>&#39;blue&#39;</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=color:#75715e># Setup the figure and axes</span>
</span></span><span style=display:flex><span>    fig, ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(nrows<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, ncols<span style=color:#f92672>=</span>num_tracks, figsize<span style=color:#f92672>=</span>(num_tracks<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create a super title for the entire plot</span>
</span></span><span style=display:flex><span>    fig<span style=color:#f92672>.</span>suptitle(wellname, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>, y<span style=color:#f92672>=</span><span style=color:#ae81ff>1.05</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop through each curve in curves_to_plot and create a track with that data</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, curve <span style=color:#f92672>in</span> enumerate(curves_to_plot):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> curve <span style=color:#f92672>in</span> facies_curves:
</span></span><span style=display:flex><span>            cmap_facies <span style=color:#f92672>=</span> colors<span style=color:#f92672>.</span>ListedColormap(facies_color[<span style=color:#ae81ff>0</span>:dataframe[curve]<span style=color:#f92672>.</span>max()], <span style=color:#e6db74>&#39;indexed&#39;</span>)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            cluster<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>repeat(np<span style=color:#f92672>.</span>expand_dims(dataframe[curve]<span style=color:#f92672>.</span>values,<span style=color:#ae81ff>1</span>), <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            im<span style=color:#f92672>=</span>ax[i]<span style=color:#f92672>.</span>imshow(cluster, interpolation<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;none&#39;</span>, cmap<span style=color:#f92672>=</span>cmap_facies, aspect<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;auto&#39;</span>,vmin<span style=color:#f92672>=</span>dataframe[curve]<span style=color:#f92672>.</span>min(),vmax<span style=color:#f92672>=</span>dataframe[curve]<span style=color:#f92672>.</span>max(), extent<span style=color:#f92672>=</span>[<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>20</span>, depth_curve<span style=color:#f92672>.</span>max(), depth_curve<span style=color:#f92672>.</span>min()])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            ax[i]<span style=color:#f92672>.</span>plot(dataframe[curve], depth_curve)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Setup a few plot cosmetics</span>
</span></span><span style=display:flex><span>        ax[i]<span style=color:#f92672>.</span>set_title(curve, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>, fontweight<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bold&#39;</span>)
</span></span><span style=display:flex><span>        ax[i]<span style=color:#f92672>.</span>grid(which<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;major&#39;</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;lightgrey&#39;</span>, linestyle<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;-&#39;</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># We want to pass in the deepest depth first, so we are displaying the data </span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># from shallow to deep</span>
</span></span><span style=display:flex><span>        ax[i]<span style=color:#f92672>.</span>set_ylim(depth_curve<span style=color:#f92672>.</span>max(), depth_curve<span style=color:#f92672>.</span>min())
</span></span><span style=display:flex><span><span style=color:#75715e>#         ax[i].set_ylim(3500, 3000)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Only set the y-label for the first track. Hide it for the rest</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            ax[i]<span style=color:#f92672>.</span>set_ylabel(<span style=color:#e6db74>&#39;DEPTH (m)&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>18</span>, fontweight<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bold&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            plt<span style=color:#f92672>.</span>setp(ax[i]<span style=color:#f92672>.</span>get_yticklabels(), visible <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Check to see if we have any logarithmic scaled curves</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> curve <span style=color:#f92672>in</span> log_curves:
</span></span><span style=display:flex><span>            ax[i]<span style=color:#f92672>.</span>set_xscale(<span style=color:#e6db74>&#39;log&#39;</span>)
</span></span><span style=display:flex><span>            ax[i]<span style=color:#f92672>.</span>grid(which<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;minor&#39;</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;lightgrey&#39;</span>, linestyle<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;-&#39;</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>tight_layout()
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>show()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cmap_facies
</span></span></code></pre></div><h3 id=splitting-data-by-well-function>Splitting Data by Well Function</h3><p>The second method we will create will be used to split up our dataframe by wells. This is done using the <code>groupby</code> function, and will allow us to store each dataframe within a list for easy access later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>well_splitter</span>(dataframe, groupby_column):
</span></span><span style=display:flex><span>    grouped <span style=color:#f92672>=</span> dataframe<span style=color:#f92672>.</span>groupby(groupby_column)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create empty lists</span>
</span></span><span style=display:flex><span>    wells_as_dfs <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    wells_wellnames <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#Split up the data by well</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> well, data <span style=color:#f92672>in</span> grouped:
</span></span><span style=display:flex><span>        wells_as_dfs<span style=color:#f92672>.</span>append(data)
</span></span><span style=display:flex><span>        wells_wellnames<span style=color:#f92672>.</span>append(well)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;index  wellname&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, name <span style=color:#f92672>in</span> enumerate(wells_wellnames):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>      </span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> wells_as_dfs, wells_wellnames
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>grouped_wells, grouped_names <span style=color:#f92672>=</span> well_splitter(workingdf, <span style=color:#e6db74>&#39;WELL&#39;</span>)
</span></span></code></pre></div><pre><code>index  wellname
0      15/9-13
1      15/9-15
2      15/9-17
3      16/1-2
4      16/1-6 A
5      16/10-1
6      16/10-2
7      16/10-3
8      16/10-5
9      16/11-1 ST3
10      16/2-11 A
11      16/2-16
</code></pre><p>We now have a list of wells and their index position with the list object.</p><h2 id=clustering---unsupervised>Clustering - Unsupervised</h2><p>In this section, we are going to setup our clustering models and run them on our dataset.</p><p>First we will import our clustering models from the sklearn library.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> sklearn.cluster <span style=color:#f92672>import</span> KMeans
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> sklearn.mixture <span style=color:#f92672>import</span> GaussianMixture
</span></span></code></pre></div><h3 id=finding-the-optimum-number-of-clusters>Finding the Optimum Number of Clusters</h3><p>To make sure that K-Means and Gaussian Mixture Modelling models are working efficiently we need to provide them with a starting number of clusters. If the number of clusters is incorrectly selected, the algorithms may not perform well.</p><p>We can attempt to identify the optimum number of clusters using an elblow plot, where the goal is to select a number for the clusters based on the &rsquo;elbow&rsquo; or inflexion formed in the results. There are other methods such as the silhouette method for picking the number of clusters.</p><p>For this example we will use the elbow plot. To do this we evalaute the model performance over a given range of clusters, and then from the plot identify the most suitable number.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>optimise_k_means</span>(data, max_k):
</span></span><span style=display:flex><span>    means <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    inertias <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>,max_k):
</span></span><span style=display:flex><span>        kmeans <span style=color:#f92672>=</span> KMeans(n_clusters<span style=color:#f92672>=</span>k)
</span></span><span style=display:flex><span>        kmeans<span style=color:#f92672>.</span>fit(data)
</span></span><span style=display:flex><span>        means<span style=color:#f92672>.</span>append(k)
</span></span><span style=display:flex><span>        inertias<span style=color:#f92672>.</span>append(kmeans<span style=color:#f92672>.</span>inertia_)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    fig <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>plot(means, inertias, <span style=color:#e6db74>&#39;o-&#39;</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#34;Number of Clusters&#34;</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#34;Inertia&#34;</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>grid(<span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>show()
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>For clustering to work, we need to remove any missing values. This is achieved using the <code>dropna()</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf<span style=color:#f92672>.</span>dropna(inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><p>We can then use the <code>describe()</code> function to make sure our data is still good after the missing data values have been removed. In this example we have gone from 133198 to 82732 depth levels.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>workingdf<span style=color:#f92672>.</span>describe()
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_39_0.png alt=png></p><p>To keep our model simple we will work with four logging measurements (columns): Gamma Ray (GR), Bulk Density (RHOB), Neutron Porosity (NPHI) and Acoustic Compressional Slowness (DTC).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>optimise_k_means(workingdf[[<span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>]], <span style=color:#ae81ff>30</span>)
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_41_0.png alt=png></p><p>In the plot above, we can see that the inertia (sum of the squared distances to the nearest cluster center) decreases as we increase the number of clusters. There is no clear defined break within this dataset, however, we can see that the slope changes from about 5 clusters onwards. The picking of this value will be dependent on the interpreter and could range from 4 to 7.</p><p>So for this example we will take 5 as the optimum number of clusters.</p><h3 id=fitting-the-clustering-models>Fitting the Clustering Models</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Create the KMeans model with the selected number of clusters</span>
</span></span><span style=display:flex><span>kmeans <span style=color:#f92672>=</span> KMeans(n_clusters<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Fit the model to our dataset</span>
</span></span><span style=display:flex><span>kmeans<span style=color:#f92672>.</span>fit(workingdf[[<span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>]])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Assign the data back to the workingdf</span>
</span></span><span style=display:flex><span>workingdf[<span style=color:#e6db74>&#39;KMeans&#39;</span>] <span style=color:#f92672>=</span> kmeans<span style=color:#f92672>.</span>labels_
</span></span></code></pre></div><p>To make the comparison simple, we will use the same number of clusters in the Gaussian Mixture Model. For this model the number of clusters parameter is known as n_components.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Create the gmm model with the selected number of clusters/components</span>
</span></span><span style=display:flex><span>gmm <span style=color:#f92672>=</span> GaussianMixture(n_components<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Fit the model to our dataset</span>
</span></span><span style=display:flex><span>gmm<span style=color:#f92672>.</span>fit(workingdf[[<span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>]])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Predict the labels</span>
</span></span><span style=display:flex><span>gmm_labels <span style=color:#f92672>=</span> gmm<span style=color:#f92672>.</span>predict(workingdf[[<span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>]])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Assign the labels back to the workingdf</span>
</span></span><span style=display:flex><span>workingdf[<span style=color:#e6db74>&#39;GMM&#39;</span>] <span style=color:#f92672>=</span> gmm_labels
</span></span></code></pre></div><h2 id=plotting-the-results>Plotting the Results</h2><p>Now that the clusters have been computed using KMeans and GMM methods, we can plot the data to see how well the predicted in relation to the labelled lithologies. Note that these methods are unsupervised and do not use the labelled data for training. We are comparing here how well unsupervised methods perform with well log data.</p><p>As we predicted into the main <code>workingdf</code> dataframe, we need to split the data up again into individual wells. We can do this by calling upon the simple function created earlier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>dfs_wells, wellnames <span style=color:#f92672>=</span> well_splitter(workingdf, <span style=color:#e6db74>&#39;WELL&#39;</span>)
</span></span></code></pre></div><pre><code>index  wellname
0      15/9-13
1      15/9-15
2      15/9-17
3      16/1-6 A
4      16/10-1
5      16/10-2
6      16/10-3
7      16/10-5
8      16/2-11 A
9      16/2-16
</code></pre><p>The first plot we will look at is the logplot. We will pass in the original lithofacies (LITH_SI) column and the newly computed KMeans and GMM results.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Setup the curves to plot</span>
</span></span><span style=display:flex><span>curves_to_plot <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>, <span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>,  <span style=color:#e6db74>&#39;LITH_SI&#39;</span>, <span style=color:#e6db74>&#39;KMeans&#39;</span>,<span style=color:#e6db74>&#39;GMM&#39;</span>]
</span></span><span style=display:flex><span>logarithmic_curves <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;RDEP&#39;</span>]
</span></span><span style=display:flex><span>facies_curve<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;KMeans&#39;</span>,<span style=color:#e6db74>&#39;GMM&#39;</span>, <span style=color:#e6db74>&#39;LITH_SI&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create plot by passing in the relevant well index number</span>
</span></span><span style=display:flex><span>well <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>cmap_facies <span style=color:#f92672>=</span> create_plot(wellnames[well], 
</span></span><span style=display:flex><span>            dfs_wells[well], 
</span></span><span style=display:flex><span>            curves_to_plot, 
</span></span><span style=display:flex><span>            dfs_wells[well][<span style=color:#e6db74>&#39;DEPTH_MD&#39;</span>], 
</span></span><span style=display:flex><span>            logarithmic_curves, facies_curve)
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_49_0.png alt=png></p><p>In the plot above we have the original Lithology and our computer KMeans and GMM cluster results in the last three subplots.</p><p>The first thing to note is that the colours do not neccessarily mean the data is from the same group across each method. There are way to map these so that the colouring is consistent, but for the purposes of this tutorial, we will not go into this.</p><p>Looking at well 16/10-1 (index 4), we have 10 separate facies/groups displayed and we can see that these mostly tie up with the changes in the logging measurements. For example the decrease in Gamma Ray (GR) from around 2300m to around 2775m ties in nicely with the blue and light blue grouping. In the KMeans and GMM models, this section has also been highlighted as being in the same cluster in both methods, however, there is no variation in this section. As both of these methods were set to a max of 5 clusters, we will not be able to capture the same degree of variation.</p><p>To resolve this, we could increase the number of clusters.</p><h3 id=viewing-results-on-scatterplots--crossplots>Viewing Results on Scatterplots / Crossplots</h3><p>Another way to view the performance of the clustering is through scatter plots. We can do this using the common density-neutron scatterplots / crossplots and using matplotlib.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fig, ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>ax1 <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplot2grid((<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>), (<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>ax1<span style=color:#f92672>.</span>scatter(dfs_wells[well][<span style=color:#e6db74>&#39;NPHI&#39;</span>], dfs_wells[well][<span style=color:#e6db74>&#39;RHOB&#39;</span>], c<span style=color:#f92672>=</span>dfs_wells[well][<span style=color:#e6db74>&#39;KMeans&#39;</span>], s<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>, cmap<span style=color:#f92672>=</span>cmap_facies)
</span></span><span style=display:flex><span>ax1<span style=color:#f92672>.</span>set_title(<span style=color:#e6db74>&#39;KMeans&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>22</span>, y<span style=color:#f92672>=</span><span style=color:#ae81ff>1.05</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ax2 <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplot2grid((<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>), (<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>ax2<span style=color:#f92672>.</span>scatter(dfs_wells[well][<span style=color:#e6db74>&#39;NPHI&#39;</span>], dfs_wells[well][<span style=color:#e6db74>&#39;RHOB&#39;</span>], c<span style=color:#f92672>=</span>dfs_wells[well][<span style=color:#e6db74>&#39;GMM&#39;</span>], s<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>ax2<span style=color:#f92672>.</span>set_title(<span style=color:#e6db74>&#39;GMM&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>22</span>, y<span style=color:#f92672>=</span><span style=color:#ae81ff>1.05</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ax3 <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplot2grid((<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>), (<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>ax3<span style=color:#f92672>.</span>scatter(dfs_wells[well][<span style=color:#e6db74>&#39;NPHI&#39;</span>], dfs_wells[well][<span style=color:#e6db74>&#39;RHOB&#39;</span>], c<span style=color:#f92672>=</span>dfs_wells[well][<span style=color:#e6db74>&#39;LITH_SI&#39;</span>], s<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>ax3<span style=color:#f92672>.</span>set_title(<span style=color:#e6db74>&#39;Lithology (Supplied)&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>22</span>, y<span style=color:#f92672>=</span><span style=color:#ae81ff>1.05</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> ax <span style=color:#f92672>in</span> [ax1, ax2, ax3]:
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>set_xlim(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0.7</span>)
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>set_ylim(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1.5</span>)
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>set_ylabel(<span style=color:#e6db74>&#39;RHOB&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>18</span>, labelpad<span style=color:#f92672>=</span><span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>set_xlabel(<span style=color:#e6db74>&#39;NPHI&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>18</span>, labelpad<span style=color:#f92672>=</span><span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>grid()
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>set_axisbelow(<span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>tick_params(axis<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;both&#39;</span>, labelsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>tight_layout()
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_52_0.png alt=png></p><p>Even though there is mixing of the clusters in each method, the interval that was discussed in the log plot section can be identified in the lower left of the plot, where we have higher density values and lower neutron porosity values.</p><p>In the KMeans grouping, this cluster shows as one complete cluster, however, in the GMM method we can see it matches closer to the supplied lithology.</p><h3 id=viewing-results-on-a-pairplot>Viewing Results on a Pairplot</h3><p>As we used four input curves for our model, we should look at all of these to see how the clusters vary. The best way to do this is to use the excellent pairplot from the seaborn library. This plot displays the relationships between the data in the dataset on a grid. This allows a quick and easy way to identify and visualise the data. Along the diagonal the distribution of the data split by cluster is also plotted.</p><p>As we are looking at well number 4 we need to pass in that dataframe to the pairplot (dfs_wells[4])</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sns<span style=color:#f92672>.</span>pairplot(dfs_wells[<span style=color:#ae81ff>4</span>], vars<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>,<span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>], hue<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;KMeans&#39;</span>, palette<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Dark2&#39;</span>,
</span></span><span style=display:flex><span>             diag_kind<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;kde&#39;</span>, plot_kws <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;s&#39;</span>: <span style=color:#ae81ff>15</span>, <span style=color:#e6db74>&#39;marker&#39;</span>:<span style=color:#e6db74>&#39;o&#39;</span>, <span style=color:#e6db74>&#39;alpha&#39;</span>:<span style=color:#ae81ff>1</span>})
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_54_1.png alt=png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sns<span style=color:#f92672>.</span>pairplot(dfs_wells[<span style=color:#ae81ff>4</span>], vars<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;GR&#39;</span>, <span style=color:#e6db74>&#39;RHOB&#39;</span>,<span style=color:#e6db74>&#39;NPHI&#39;</span>, <span style=color:#e6db74>&#39;DTC&#39;</span>], hue<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;GMM&#39;</span>, palette<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Dark2&#39;</span>,
</span></span><span style=display:flex><span>             diag_kind<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;kde&#39;</span>, plot_kws <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;s&#39;</span>: <span style=color:#ae81ff>15</span>, <span style=color:#e6db74>&#39;marker&#39;</span>:<span style=color:#e6db74>&#39;o&#39;</span>, <span style=color:#e6db74>&#39;alpha&#39;</span>:<span style=color:#ae81ff>1</span>})
</span></span></code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_55_1.png alt=png></p><p>This provides us a much nicer plot to look at and also allows us to see how the data is clustered in the other logging curves. We can see that the GMM model provides some improvement in defining the clusters, especially in the DTC vs RHOB plot.</p><h1 id=summary>Summary</h1><p>In this article we have covered the basics for carrying out unsupervised cluster analysis using two popular algorithms - KMeans Clustering and Gaussian Mixture Modelling. Using an optimisation method we have determined, by eye, that the optimum number of clusters was five, however, it is worth experimenting with more clusters to see if this provides a better match.</p><p>Once the clustering was complete, we saw multiple ways to visualise the results: a standard log plot setup, scatter plots and seaborn&rsquo;s pairplot.</p><p>As K-Means clustering utilises spherical clusters, it may not always be appropriate to well log data and the subsurface. However, Gaussian Mixture Modelling does appear to provide a slight improvement in clustering.</p><p><em><strong>Thanks for reading!</strong></em></p><p><em>If you have found this article useful, please feel free to check out my other articles looking at various aspects of Python and well log data. You can also find my code used in this article and others at <a href=https://github.com/andymcdgeo>GitHub</a>.</em></p><p><em>If you want to get in touch you can find me on <a href=https://www.linkedin.com/in/andymcdonaldgeo/>LinkedIn</a> or at my <a href=http://andymcdonald.scot/>website</a>.</em></p><p><em>Interested in learning more about python and well log data or petrophysics? Follow me on <a href=https://medium.com/@andymcdonaldgeo>Medium</a>.</em></p><p>If you have enjoyed this article or any others and want to show your appreciate you are welcome to <a href=https://www.buymeacoffee.com/andymcdonaldgeo>Buy Me a Coffee</a></p><h1 id=references>References</h1><p>Bormann, Peter, Aursand, Peder, Dilib, Fahad, Manral, Surrender, & Dischington, Peter. (2020). FORCE 2020 Well well log and lithofacies dataset for machine learning competition [Data set]. Zenodo. <a href=http://doi.org/10.5281/zenodo.4351156>http://doi.org/10.5281/zenodo.4351156</a></p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">TAGGED IN</span><br><a class="tag tag--primary tag--small" href=https://www.andymcdonald.scot/tags/petrophysics/>petrophysics</a>
<a class="tag tag--primary tag--small" href=https://www.andymcdonald.scot/tags/python/>python</a>
<a class="tag tag--primary tag--small" href=https://www.andymcdonald.scot/tags/matplotlib/>matplotlib</a>
<a class="tag tag--primary tag--small" href=https://www.andymcdonald.scot/tags/lasio/>lasio</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://www.andymcdonald.scot/blog/2021/2021-06-07-public-datasets-for-geoscience-and-petrophysics/ data-tooltip="Public Datasets for Geoscience and Petrophysical Machine Learning" aria-label="NEXT: Public Datasets for Geoscience and Petrophysical Machine Learning"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://www.andymcdonald.scot/blog/2021/2021-04-21-loading-well-log-data-from-dlis-using-python/ data-tooltip="Loading Well Log Data From DLIS using Python" aria-label="PREVIOUS: Loading Well Log Data From DLIS using Python"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.facebook.com/sharer/sharer.php?u=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/" title="Share on Facebook" aria-label="Share on Facebook"><i class="fab fa-facebook-square" aria-hidden=true></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://twitter.com/intent/tweet?text=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/" title="Share on Twitter" aria-label="Share on Twitter"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/" title="Share on Linkedin" aria-label="Share on Linkedin"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread aria-label="Leave a comment"><i class="far fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=disqus_thread><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div><script type=text/javascript>var disqus_config=function(){this.page.url="https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/",this.page.identifier="/blog/2021/2021-06-02-unsupervised-clustering-of-facies/"};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="hugo-tranquilpeak-theme",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2022 Andy McDonald. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=2><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://www.andymcdonald.scot/blog/2021/2021-06-07-public-datasets-for-geoscience-and-petrophysics/ data-tooltip="Public Datasets for Geoscience and Petrophysical Machine Learning" aria-label="NEXT: Public Datasets for Geoscience and Petrophysical Machine Learning"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://www.andymcdonald.scot/blog/2021/2021-04-21-loading-well-log-data-from-dlis-using-python/ data-tooltip="Loading Well Log Data From DLIS using Python" aria-label="PREVIOUS: Loading Well Log Data From DLIS using Python"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.facebook.com/sharer/sharer.php?u=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/" title="Share on Facebook" aria-label="Share on Facebook"><i class="fab fa-facebook-square" aria-hidden=true></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://twitter.com/intent/tweet?text=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/" title="Share on Twitter" aria-label="Share on Twitter"><i class="fab fa-twitter" aria-hidden=true></i></a></li><li class="post-action hide-xs"><a class="post-action-btn btn btn--default" target=new href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/" title="Share on Linkedin" aria-label="Share on Linkedin"><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#disqus_thread aria-label="Leave a comment"><i class="far fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div><div id=share-options-bar class=share-options-bar data-behavior=2><i id=btn-close-shareoptions class="fa fa-times"></i><ul class=share-options><li class=share-option><a class=share-option-btn target=new href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.andymcdonald.scot%2Fblog%2F2021%2F2021-06-02-unsupervised-clustering-of-facies%2F" aria-label="Share on Facebook"><i class="fab fa-facebook-square" aria-hidden=true></i><span>Share on Facebook</span></a></li><li class=share-option><a class=share-option-btn target=new href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fwww.andymcdonald.scot%2Fblog%2F2021%2F2021-06-02-unsupervised-clustering-of-facies%2F" aria-label="Share on Twitter"><i class="fab fa-twitter" aria-hidden=true></i><span>Share on Twitter</span></a></li><li class=share-option><a class=share-option-btn target=new href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fwww.andymcdonald.scot%2Fblog%2F2021%2F2021-06-02-unsupervised-clustering-of-facies%2F" aria-label="Share on Linkedin"><i class="fab fa-linkedin" aria-hidden=true></i><span>Share on Linkedin</span></a></li></ul></div><div id=share-options-mask class=share-options-mask></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://www.andymcdonald.scot/images/andy2.png alt="Author's picture"><h4 id=about-card-name>Andy McDonald</h4><div id=about-card-bio>Super bio with markdown support <strong>COOL</strong></div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Petrophysicist, Geoscientist, Data Scientist</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Scotland</div></div></div><div id=cover style=background-image:url(https://www.andymcdonald.scot/images/massimo-botturi-zFYUsLk_50Y-unsplash.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://www.andymcdonald.scot/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:'',useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(t,e){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(e)})})</script></body></html>