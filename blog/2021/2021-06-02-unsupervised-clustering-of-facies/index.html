<!doctype html><html lang=en-uk><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content="map[]"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.andymcdonald.scot\/"},"articleSection":"blog","name":"How to Use Unsupervised Clustering on Well Log Data","headline":"How to Use Unsupervised Clustering on Well Log Data","description":"See how to use Python and Unsupervised Machine Learning to identify facies from well log data.","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2021","datePublished":"2021-06-02 00:00:00 \u002b0000 UTC","dateModified":"2021-06-02 00:00:00 \u002b0000 UTC","url":"https:\/\/www.andymcdonald.scot\/blog\/2021\/2021-06-02-unsupervised-clustering-of-facies\/","wordCount":"2837","keywords":["petrophysics","python","matplotlib","lasio","Blog"]}</script><title>How to Use Unsupervised Clustering on Well Log Data</title><link rel="shortcut icon" href=https://www.andymcdonald.scot/images/favicon-16x16.png><link href=https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css rel=stylesheet><script defer src=https://use.fontawesome.com/releases/v5.0.11/js/all.js integrity=sha384-ImVoB8Er8knetgQakxuBS4G3RSkyD8IZVVQCAnmRJrDwqJFYUE4YOv+DbIofcO9C crossorigin=anonymous></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Alice|Open+Sans:400,300,700"><link rel=stylesheet href=https://www.andymcdonald.scot/assets/css/main.min.2c07d0baa1bed3e1fc59b3f921970d2e1ea6dc63af9e305cd2ebb66c401cc33c.css media=all><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;400;500&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.1/css/all.min.css integrity="sha256-2XFplPlrFClt0bIdPgpz8H7ojnk10H69xRqd9+uTShA=" crossorigin=anonymous><script async src="https://www.googletagmanager.com/gtag/js?id=G-DWZLFXGHNF"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-DWZLFXGHNF')</script><script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=andymcdonaldgeo data-description="Support me on Buy me a coffee!" data-message="Support me on Buy Me a Coffee" data-color=#FFDD00 data-position=Right data-x_margin=18 data-y_margin=18></script></head><body class=home><header id=header><div id=head style=background-image:url(https://www.andymcdonald.scot/images/header_img.jpg),linear-gradient(rgba(0,0,0,.5),rgba(0,0,0,.5))><h1 id=logo class=text-center><img class=img-circle src=https://www.andymcdonald.scot/images/andy.png alt>
<span class=title>Andy McDonald</span>
<span class=tagline2>Petrophysicist | Geoscientist | Data Scientist</span><div class=header-underline></div><div class=social-head><a href=https://www.linkedin.com/andymcdonaldgeo target=_blank><i class="fab fa-linkedin fa-1x"></i></a>
<a href=https://www.researchgate.net/profile/Andrew-Mcdonald-15 target=_blank><i class="fab fa-researchgate fa-1x"></i></a>
<a href=https://twitter.com/geoandymcd target=_blank><i class="fab fa-twitter-square fa-1x"></i></a>
<a href=https://github.com/andymcdgeo target=_blank><i class="fab fa-github-square fa-1x"></i></a>
<a href=https://andymcdonaldgeo.medium.com target=_blank><i class="fab fa-medium fa-1x"></i></a></div></h1></div><div class=landing></div><nav class="navbar navbar-default navbar-sticky"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#bs-example-navbar-collapse-1 aria-expanded=true>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button></div><div class="navbar-collapse collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=https://www.andymcdonald.scot/>Home</a></li><li><a href=https://www.andymcdonald.scot/blog/>Blog</a></li><li><a href=https://www.andymcdonald.scot/#projects>Projects</a></li><li><a href=https://www.andymcdonald.scot/publications/>Publications</a></li></ul></div></div></nav></header><main id=main><div class=container><div class="row topspace"><div class="col-sm-8 col-sm-offset-2"><article class=post><header class=entry-header><h2 class=title>How to Use Unsupervised Clustering on Well Log Data</h2><div class=featured-image style=background-image:url(/images/featured/2021-06-Unsupervised.png)></div><div class=entry-meta><span class=posted-on><i class="far fa-calendar-alt"></i>Published on: &nbsp;June 2, 2021<i class="far fa-clock"></i> 14 min read
<span class=post-categories><i class="far fa-folder"></i><ul><li><a href=https://www.andymcdonald.scot/categories/petrophysics/>petrophysics</a></li><li><a href=https://www.andymcdonald.scot/categories/python/>python</a></li><li><a href=https://www.andymcdonald.scot/categories/las/>las</a></li></ul></span></span></div></header><div class=row><div class=col-sm-12><div id=toc><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#what-is-clustering--cluster-analysis>What is Clustering / Cluster Analysis?</a><ul><li><a href=#k-means-clustering>K-Means Clustering</a></li><li><a href=#gaussian-mixture-modelling>Gaussian Mixture Modelling</a></li></ul></li><li><a href=#dataset>Dataset</a></li><li><a href=#importing-libraries--data-loading>Importing Libraries & Data Loading</a></li><li><a href=#column-remapping--renaming>Column Remapping / Renaming</a></li><li><a href=#visualising-the-data>Visualising the Data</a><ul><li><a href=#splitting-data-by-well-function>Splitting Data by Well Function</a></li></ul></li><li><a href=#clustering---unsupervised>Clustering - Unsupervised</a><ul><li><a href=#finding-the-optimum-number-of-clusters>Finding the Optimum Number of Clusters</a></li><li><a href=#fitting-the-clustering-models>Fitting the Clustering Models</a></li></ul></li><li><a href=#plotting-the-results>Plotting the Results</a><ul><li><a href=#viewing-results-on-scatterplots--crossplots>Viewing Results on Scatterplots / Crossplots</a></li><li><a href=#viewing-results-on-a-pairplot>Viewing Results on a Pairplot</a></li></ul></li></ul></nav></div></div></div><div class=entry-content><p>Understanding the subsurface lithology is an important task in geoscience and petrophysics. Using a variety of electrical measurements generated from well logging technology we are able to make inferences about the underlying geology, such as the lithology, facies, porosity, and permeability.</p><p>Machine Learning algorithms have routinely been adopted to group well log measurements into distinct lithological groupings, known as facies. This process can be achieved using either unsupervised learning or supervised learning algorithms.</p><p><strong>Supervised learning</strong> is the most common and practical of machine learning tasks and it is designed to learn from example using input data that has been mapped to the &ldquo;correct&rdquo; output. Alternatively, we can run the modelling using <strong>Unsupervised Learning</strong>, where we let the algorithms identify underlying patterns within the data that may not be easily visible during data exploration.</p><p>In this tutorial we will be carrying out unsupervised learning classification using three clustering methods (K Means Clustering, Gaussian Mixture Modelling and DBSCAN) and comparing the results with an established Lithofacies curve.</p><h2 id=what-is-clustering--cluster-analysis>What is Clustering / Cluster Analysis?</h2><p>Clustering of data is a common form of exploratory data analysis (EDA) which is used to divide up the data into different groups based on shared characteristics or properties. Data points that are similar to each other are grouped together in the same cluster, and those that are different are placed in another cluster.</p><h3 id=k-means-clustering>K-Means Clustering</h3><p>K-Means clustering is a very commonly used unsupervised machine learning algorithm. It is used to group data into K number of clusters by minimising the distance between the data point and the centroid.</p><p>The centroid is initialised at k random points in the data space and all points around it are assigned to the relevant cluster based on the distance to the centroid. The centroid is then adjusted to the central point of the cluster and the points surrounding it are reassigned. This continues until either there is no change in the centroids or the points remain in the same cluster or until a maximum number of iterations is reached.</p><p>K-Means is a hard clustering method where a data point either belongs to a cluster or it does not. It also carries out clustering by applying a circle (or hyper-sphere in multi-dimensional datasets)to the data.</p><h3 id=gaussian-mixture-modelling>Gaussian Mixture Modelling</h3><p>The GMM method also allows data points to be clustered, except that it accounts for data variance, results in a softer classification and rather than being distance based it is distribution based.</p><p>Also, the data point being classified has a probability of being one cluster or another.</p><p>While K-Means clustering works great if the data clusters are circular, however, in petrophysical and geological situations data rarely forms nice circular patterns. GMM modelling uses eliptical shaped cluster/decision boundaries and are therefore more flexible.</p><p>An excellent article looking at the differences between the two methods can be found at <a href=https://www.analyticsvidhya.com/blog/2019/10/gaussian-mixture-models-clustering/>https://www.analyticsvidhya.com/blog/2019/10/gaussian-mixture-models-clustering/</a></p><h2 id=dataset>Dataset</h2><p>The dataset we are using for this tutorial forms part of a Machine Learning competition run by Xeek and FORCE 2020 (<a href=https://doi.org/10.5281/zenodo.4351155)>https://doi.org/10.5281/zenodo.4351155)</a>. The objective of the compettion was to predict lithology from existing labelled data. The dataset consists of 118 wells from the Norwegian Sea.</p><h2 id=importing-libraries--data-loading>Importing Libraries & Data Loading</h2><p>The first step of the project is to import the libraries that we require. For this example we will be using <a href=https://numpy.org>NumPy</a> for working with arrays, <a href=https://pandas.pydata.org>pandas</a> for storing data, <a href=https://seaborn.pydata.org>seaborn</a> and <a href=https://matplotlib.org>matplotlib</a> for displaying the data.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>pandas</span> <span class=kn>as</span> <span class=nn>pd</span>
<span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=kn>as</span> <span class=nn>plt</span>
<span class=kn>import</span> <span class=nn>seaborn</span> <span class=kn>as</span> <span class=nn>sns</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>
<span class=kn>import</span> <span class=nn>matplotlib.colors</span> <span class=kn>as</span> <span class=nn>colors</span>
</code></pre></div><p>We will then read in the data using <code>pd.read_csv</code> and then view the first five rows using the <code>head()</code> method.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=s2>&#34;Data/xeek_train_subset.csv&#34;</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>df</span><span class=o>.</span><span class=n>describe</span><span class=p>()</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_5_0.png alt=png></p><p>As it is quite a big table, we can view the columns by calling upon <code>df.columns</code>.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>df</span><span class=o>.</span><span class=n>columns</span>
</code></pre></div><pre><code>Index(['WELL', 'DEPTH_MD', 'X_LOC', 'Y_LOC', 'Z_LOC', 'GROUP', 'FORMATION',
       'CALI', 'RSHA', 'RMED', 'RDEP', 'RHOB', 'GR', 'SGR', 'NPHI', 'PEF',
       'DTC', 'SP', 'BS', 'ROP', 'DTS', 'DCAL', 'DRHO', 'MUDWEIGHT', 'RMIC',
       'ROPA', 'RXO', 'FORCE_2020_LITHOFACIES_LITHOLOGY',
       'FORCE_2020_LITHOFACIES_CONFIDENCE'],
      dtype='object')
</code></pre><p>We don&rsquo;t need all of the columns for this example, so we will take a copy of the dataframe with the required logging measurements, including the well name and the depth curve.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span> <span class=o>=</span> <span class=n>df</span><span class=p>[[</span><span class=s2>&#34;WELL&#34;</span><span class=p>,</span> <span class=s2>&#34;DEPTH_MD&#34;</span><span class=p>,</span> <span class=s2>&#34;RDEP&#34;</span><span class=p>,</span> <span class=s2>&#34;RHOB&#34;</span><span class=p>,</span> <span class=s2>&#34;GR&#34;</span><span class=p>,</span> <span class=s2>&#34;NPHI&#34;</span><span class=p>,</span> <span class=s2>&#34;PEF&#34;</span><span class=p>,</span> <span class=s2>&#34;DTC&#34;</span><span class=p>,</span> <span class=s2>&#34;FORCE_2020_LITHOFACIES_LITHOLOGY&#34;</span><span class=p>]]</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</code></pre></div><p>We will also rename the <code>FORCE_2020_LITHOFACIES_LITHOLOGY</code> column to something simpler like <code>FACIES</code>.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span><span class=o>.</span><span class=n>rename</span><span class=p>(</span><span class=n>columns</span><span class=o>=</span><span class=p>{</span><span class=s1>&#39;FORCE_2020_LITHOFACIES_LITHOLOGY&#39;</span><span class=p>:</span><span class=s1>&#39;FACIES&#39;</span><span class=p>},</span> <span class=n>inplace</span><span class=o>=</span><span class=bp>True</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_12_0.png alt=png></p><h2 id=column-remapping--renaming>Column Remapping / Renaming</h2><p>To make things simpler with plotting, and understanding what the lithology numbers supplied with the data mean, we can create two dictionaries and map the <code>FACIES</code> column to two new columns.</p><p>The first is creating a dictionary for the string representations of the numbers.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>lithology_numbers</span> <span class=o>=</span> <span class=p>{</span><span class=mi>30000</span><span class=p>:</span> <span class=s1>&#39;Sandstone&#39;</span><span class=p>,</span>
                 <span class=mi>65030</span><span class=p>:</span> <span class=s1>&#39;Sandstone/Shale&#39;</span><span class=p>,</span>
                 <span class=mi>65000</span><span class=p>:</span> <span class=s1>&#39;Shale&#39;</span><span class=p>,</span>
                 <span class=mi>80000</span><span class=p>:</span> <span class=s1>&#39;Marl&#39;</span><span class=p>,</span>
                 <span class=mi>74000</span><span class=p>:</span> <span class=s1>&#39;Dolomite&#39;</span><span class=p>,</span>
                 <span class=mi>70000</span><span class=p>:</span> <span class=s1>&#39;Limestone&#39;</span><span class=p>,</span>
                 <span class=mi>70032</span><span class=p>:</span> <span class=s1>&#39;Chalk&#39;</span><span class=p>,</span>
                 <span class=mi>88000</span><span class=p>:</span> <span class=s1>&#39;Halite&#39;</span><span class=p>,</span>
                 <span class=mi>86000</span><span class=p>:</span> <span class=s1>&#39;Anhydrite&#39;</span><span class=p>,</span>
                 <span class=mi>99000</span><span class=p>:</span> <span class=s1>&#39;Tuff&#39;</span><span class=p>,</span>
                 <span class=mi>90000</span><span class=p>:</span> <span class=s1>&#39;Coal&#39;</span><span class=p>,</span>
                 <span class=mi>93000</span><span class=p>:</span> <span class=s1>&#39;Basement&#39;</span><span class=p>}</span>
</code></pre></div><p>The second dictionary is simplifying the lithology number to range from 1 to 12 instead of the large range of numbers used in the original data. This will help when it comes to making a log plot.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>simple_lithology_numbers</span> <span class=o>=</span> <span class=p>{</span><span class=mi>30000</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
                 <span class=mi>65030</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span>
                 <span class=mi>65000</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span>
                 <span class=mi>80000</span><span class=p>:</span> <span class=mi>4</span><span class=p>,</span>
                 <span class=mi>74000</span><span class=p>:</span> <span class=mi>5</span><span class=p>,</span>
                 <span class=mi>70000</span><span class=p>:</span> <span class=mi>6</span><span class=p>,</span>
                 <span class=mi>70032</span><span class=p>:</span> <span class=mi>7</span><span class=p>,</span>
                 <span class=mi>88000</span><span class=p>:</span> <span class=mi>8</span><span class=p>,</span>
                 <span class=mi>86000</span><span class=p>:</span> <span class=mi>9</span><span class=p>,</span>
                 <span class=mi>99000</span><span class=p>:</span> <span class=mi>10</span><span class=p>,</span>
                 <span class=mi>90000</span><span class=p>:</span> <span class=mi>11</span><span class=p>,</span>
                 <span class=mi>93000</span><span class=p>:</span> <span class=mi>12</span><span class=p>}</span>
</code></pre></div><p>To create new columns in our dataframe, we start with defining the column name <code>workingdf['LITH']</code> and then we assign the mapped values using the <code>.map()</code> method.</p><p>We do this for both the string and simple number representations of the facies.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span><span class=p>[</span><span class=s1>&#39;LITH&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>workingdf</span><span class=p>[</span><span class=s1>&#39;FACIES&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=n>lithology_numbers</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span><span class=p>[</span><span class=s1>&#39;LITH_SI&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>workingdf</span><span class=p>[</span><span class=s1>&#39;FACIES&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=n>simple_lithology_numbers</span><span class=p>)</span>
</code></pre></div><p>When we view the dataframe, we can see that we now have our two new columns at the end.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_22_0.png alt=png></p><h2 id=visualising-the-data>Visualising the Data</h2><p>As there is already a FACIES column with this data, we can take a quick look to see how the data is distributed across each lithofacies.</p><p>To do this we can use Seaborn&rsquo;s <code>FacetGrid</code> method to plot individual density-neutron crossplots (scatterplots) for each lithology.</p><p>The FacetGrid is used to create an underlying structure for the plot. In this example, the FacetGrid has been passed the dataframe we are working with (<code>workingdf</code>), the column we want to split the plots up by (<code>col</code>) and the point at which we want to wrap to a new row (<code>col_wrap</code>). In this instance, once there are 4 columns, then the data will wrap.</p><p>We can then map a density neutron crossplot ontop of that <code>FacetGrid</code>.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>g</span> <span class=o>=</span> <span class=n>sns</span><span class=o>.</span><span class=n>FacetGrid</span><span class=p>(</span><span class=n>workingdf</span><span class=p>,</span> <span class=n>col</span><span class=o>=</span><span class=s1>&#39;LITH&#39;</span><span class=p>,</span> <span class=n>col_wrap</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>
<span class=n>g</span><span class=o>.</span><span class=n>map</span><span class=p>(</span><span class=n>sns</span><span class=o>.</span><span class=n>scatterplot</span><span class=p>,</span> <span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span> <span class=n>alpha</span><span class=o>=</span><span class=mf>0.5</span><span class=p>)</span>
<span class=n>g</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>xlim</span><span class=o>=</span><span class=p>(</span><span class=o>-</span><span class=mf>0.15</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
<span class=n>g</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>ylim</span><span class=o>=</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_24_1.png alt=png></p><p>Before we plot any data we need to create a few functions. The first is a create plot function, which will take a number of arguments and our facies curve, and will generate a conventional log plot.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>create_plot</span><span class=p>(</span><span class=n>wellname</span><span class=p>,</span> <span class=n>dataframe</span><span class=p>,</span> <span class=n>curves_to_plot</span><span class=p>,</span> <span class=n>depth_curve</span><span class=p>,</span> <span class=n>log_curves</span><span class=o>=</span><span class=p>[],</span> <span class=n>facies_curves</span><span class=o>=</span><span class=p>[]):</span>
    <span class=c1># Count the number of tracks we need</span>
    <span class=n>num_tracks</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>curves_to_plot</span><span class=p>)</span>
    
    <span class=n>facies_color</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;#F4D03F&#39;</span><span class=p>,</span> <span class=s1>&#39;#F5B041&#39;</span><span class=p>,</span><span class=s1>&#39;#DC7633&#39;</span><span class=p>,</span><span class=s1>&#39;#6E2C00&#39;</span><span class=p>,</span> <span class=s1>&#39;#1B4F72&#39;</span><span class=p>,</span><span class=s1>&#39;#2E86C1&#39;</span><span class=p>,</span> <span class=s1>&#39;#AED6F1&#39;</span><span class=p>,</span> <span class=s1>&#39;#A569BD&#39;</span><span class=p>,</span> <span class=s1>&#39;#196F3D&#39;</span><span class=p>,</span> <span class=s1>&#39;red&#39;</span><span class=p>,</span><span class=s1>&#39;black&#39;</span><span class=p>,</span> <span class=s1>&#39;blue&#39;</span><span class=p>]</span>
    
            
    <span class=c1># Setup the figure and axes</span>
    <span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=n>nrows</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>ncols</span><span class=o>=</span><span class=n>num_tracks</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=n>num_tracks</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span> <span class=mi>10</span><span class=p>))</span>
    
    <span class=c1># Create a super title for the entire plot</span>
    <span class=n>fig</span><span class=o>.</span><span class=n>suptitle</span><span class=p>(</span><span class=n>wellname</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>20</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mf>1.05</span><span class=p>)</span>
    
    <span class=c1># Loop through each curve in curves_to_plot and create a track with that data</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>curve</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>curves_to_plot</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>curve</span> <span class=ow>in</span> <span class=n>facies_curves</span><span class=p>:</span>
            <span class=n>cmap_facies</span> <span class=o>=</span> <span class=n>colors</span><span class=o>.</span><span class=n>ListedColormap</span><span class=p>(</span><span class=n>facies_color</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=n>dataframe</span><span class=p>[</span><span class=n>curve</span><span class=p>]</span><span class=o>.</span><span class=n>max</span><span class=p>()],</span> <span class=s1>&#39;indexed&#39;</span><span class=p>)</span>
            
            <span class=n>cluster</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>repeat</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>expand_dims</span><span class=p>(</span><span class=n>dataframe</span><span class=p>[</span><span class=n>curve</span><span class=p>]</span><span class=o>.</span><span class=n>values</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
            <span class=n>im</span><span class=o>=</span><span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>imshow</span><span class=p>(</span><span class=n>cluster</span><span class=p>,</span> <span class=n>interpolation</span><span class=o>=</span><span class=s1>&#39;none&#39;</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=n>cmap_facies</span><span class=p>,</span> <span class=n>aspect</span><span class=o>=</span><span class=s1>&#39;auto&#39;</span><span class=p>,</span><span class=n>vmin</span><span class=o>=</span><span class=n>dataframe</span><span class=p>[</span><span class=n>curve</span><span class=p>]</span><span class=o>.</span><span class=n>min</span><span class=p>(),</span><span class=n>vmax</span><span class=o>=</span><span class=n>dataframe</span><span class=p>[</span><span class=n>curve</span><span class=p>]</span><span class=o>.</span><span class=n>max</span><span class=p>(),</span> <span class=n>extent</span><span class=o>=</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=mi>20</span><span class=p>,</span> <span class=n>depth_curve</span><span class=o>.</span><span class=n>max</span><span class=p>(),</span> <span class=n>depth_curve</span><span class=o>.</span><span class=n>min</span><span class=p>()])</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>dataframe</span><span class=p>[</span><span class=n>curve</span><span class=p>],</span> <span class=n>depth_curve</span><span class=p>)</span>

        
        <span class=c1># Setup a few plot cosmetics</span>
        <span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=n>curve</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>14</span><span class=p>,</span> <span class=n>fontweight</span><span class=o>=</span><span class=s1>&#39;bold&#39;</span><span class=p>)</span>
        <span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>grid</span><span class=p>(</span><span class=n>which</span><span class=o>=</span><span class=s1>&#39;major&#39;</span><span class=p>,</span> <span class=n>color</span><span class=o>=</span><span class=s1>&#39;lightgrey&#39;</span><span class=p>,</span> <span class=n>linestyle</span><span class=o>=</span><span class=s1>&#39;-&#39;</span><span class=p>)</span>
        
        <span class=c1># We want to pass in the deepest depth first, so we are displaying the data </span>
        <span class=c1># from shallow to deep</span>
        <span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set_ylim</span><span class=p>(</span><span class=n>depth_curve</span><span class=o>.</span><span class=n>max</span><span class=p>(),</span> <span class=n>depth_curve</span><span class=o>.</span><span class=n>min</span><span class=p>())</span>
<span class=c1>#         ax[i].set_ylim(3500, 3000)</span>

        <span class=c1># Only set the y-label for the first track. Hide it for the rest</span>
        <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
            <span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s1>&#39;DEPTH (m)&#39;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>18</span><span class=p>,</span> <span class=n>fontweight</span><span class=o>=</span><span class=s1>&#39;bold&#39;</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>plt</span><span class=o>.</span><span class=n>setp</span><span class=p>(</span><span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>get_yticklabels</span><span class=p>(),</span> <span class=n>visible</span> <span class=o>=</span> <span class=bp>False</span><span class=p>)</span>
        
        <span class=c1># Check to see if we have any logarithmic scaled curves</span>
        <span class=k>if</span> <span class=n>curve</span> <span class=ow>in</span> <span class=n>log_curves</span><span class=p>:</span>
            <span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>set_xscale</span><span class=p>(</span><span class=s1>&#39;log&#39;</span><span class=p>)</span>
            <span class=n>ax</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>grid</span><span class=p>(</span><span class=n>which</span><span class=o>=</span><span class=s1>&#39;minor&#39;</span><span class=p>,</span> <span class=n>color</span><span class=o>=</span><span class=s1>&#39;lightgrey&#39;</span><span class=p>,</span> <span class=n>linestyle</span><span class=o>=</span><span class=s1>&#39;-&#39;</span><span class=p>)</span>
        

    
    <span class=n>plt</span><span class=o>.</span><span class=n>tight_layout</span><span class=p>()</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
    
    <span class=k>return</span> <span class=n>cmap_facies</span>
</code></pre></div><h3 id=splitting-data-by-well-function>Splitting Data by Well Function</h3><p>The second method we will create will be used to split up our dataframe by wells. This is done using the <code>groupby</code> function, and will allow us to store each dataframe within a list for easy access later.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>well_splitter</span><span class=p>(</span><span class=n>dataframe</span><span class=p>,</span> <span class=n>groupby_column</span><span class=p>):</span>
    <span class=n>grouped</span> <span class=o>=</span> <span class=n>dataframe</span><span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=n>groupby_column</span><span class=p>)</span>
    
    <span class=c1># Create empty lists</span>
    <span class=n>wells_as_dfs</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>wells_wellnames</span> <span class=o>=</span> <span class=p>[]</span>

    <span class=c1>#Split up the data by well</span>
    <span class=k>for</span> <span class=n>well</span><span class=p>,</span> <span class=n>data</span> <span class=ow>in</span> <span class=n>grouped</span><span class=p>:</span>
        <span class=n>wells_as_dfs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=n>wells_wellnames</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>well</span><span class=p>)</span>

    <span class=k>print</span><span class=p>(</span><span class=s1>&#39;index  wellname&#39;</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>name</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>wells_wellnames</span><span class=p>):</span>
        <span class=k>print</span><span class=p>(</span><span class=n>f</span><span class=s1>&#39;{i}      {name}&#39;</span><span class=p>)</span>
    
    <span class=k>return</span> <span class=n>wells_as_dfs</span><span class=p>,</span> <span class=n>wells_wellnames</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>grouped_wells</span><span class=p>,</span> <span class=n>grouped_names</span> <span class=o>=</span> <span class=n>well_splitter</span><span class=p>(</span><span class=n>workingdf</span><span class=p>,</span> <span class=s1>&#39;WELL&#39;</span><span class=p>)</span>
</code></pre></div><pre><code>index  wellname
0      15/9-13
1      15/9-15
2      15/9-17
3      16/1-2
4      16/1-6 A
5      16/10-1
6      16/10-2
7      16/10-3
8      16/10-5
9      16/11-1 ST3
10      16/2-11 A
11      16/2-16
</code></pre><p>We now have a list of wells and their index position with the list object.</p><h2 id=clustering---unsupervised>Clustering - Unsupervised</h2><p>In this section, we are going to setup our clustering models and run them on our dataset.</p><p>First we will import our clustering models from the sklearn library.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>sklearn.cluster</span> <span class=kn>import</span> <span class=n>KMeans</span>
<span class=kn>from</span> <span class=nn>sklearn.mixture</span> <span class=kn>import</span> <span class=n>GaussianMixture</span>
</code></pre></div><h3 id=finding-the-optimum-number-of-clusters>Finding the Optimum Number of Clusters</h3><p>To make sure that K-Means and Gaussian Mixture Modelling models are working efficiently we need to provide them with a starting number of clusters. If the number of clusters is incorrectly selected, the algorithms may not perform well.</p><p>We can attempt to identify the optimum number of clusters using an elblow plot, where the goal is to select a number for the clusters based on the &lsquo;elbow&rsquo; or inflexion formed in the results. There are other methods such as the silhouette method for picking the number of clusters.</p><p>For this example we will use the elbow plot. To do this we evalaute the model performance over a given range of clusters, and then from the plot identify the most suitable number.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>optimise_k_means</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>max_k</span><span class=p>):</span>
    <span class=n>means</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>inertias</span> <span class=o>=</span> <span class=p>[]</span>
    
    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=n>max_k</span><span class=p>):</span>
        <span class=n>kmeans</span> <span class=o>=</span> <span class=n>KMeans</span><span class=p>(</span><span class=n>n_clusters</span><span class=o>=</span><span class=n>k</span><span class=p>)</span>
        <span class=n>kmeans</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
        <span class=n>means</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>k</span><span class=p>)</span>
        <span class=n>inertias</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>kmeans</span><span class=o>.</span><span class=n>inertia_</span><span class=p>)</span>
        
    <span class=n>fig</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>5</span><span class=p>))</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>means</span><span class=p>,</span> <span class=n>inertias</span><span class=p>,</span> <span class=s1>&#39;o-&#39;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&#34;Number of Clusters&#34;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>ylabel</span><span class=p>(</span><span class=s2>&#34;Inertia&#34;</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>grid</span><span class=p>(</span><span class=bp>True</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
    
</code></pre></div><p>For clustering to work, we need to remove any missing values. This is achieved using the <code>dropna()</code> function.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span><span class=o>.</span><span class=n>dropna</span><span class=p>(</span><span class=n>inplace</span><span class=o>=</span><span class=bp>True</span><span class=p>)</span>
</code></pre></div><p>We can then use the <code>describe()</code> function to make sure our data is still good after the missing data values have been removed. In this example we have gone from 133198 to 82732 depth levels.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>workingdf</span><span class=o>.</span><span class=n>describe</span><span class=p>()</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_39_0.png alt=png></p><p>To keep our model simple we will work with four logging measurements (columns): Gamma Ray (GR), Bulk Density (RHOB), Neutron Porosity (NPHI) and Acoustic Compressional Slowness (DTC).</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>optimise_k_means</span><span class=p>(</span><span class=n>workingdf</span><span class=p>[[</span><span class=s1>&#39;GR&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span> <span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;DTC&#39;</span><span class=p>]],</span> <span class=mi>30</span><span class=p>)</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_41_0.png alt=png></p><p>In the plot above, we can see that the inertia (sum of the squared distances to the nearest cluster center) decreases as we increase the number of clusters. There is no clear defined break within this dataset, however, we can see that the slope changes from about 5 clusters onwards. The picking of this value will be dependent on the interpreter and could range from 4 to 7.</p><p>So for this example we will take 5 as the optimum number of clusters.</p><h3 id=fitting-the-clustering-models>Fitting the Clustering Models</h3><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># Create the KMeans model with the selected number of clusters</span>
<span class=n>kmeans</span> <span class=o>=</span> <span class=n>KMeans</span><span class=p>(</span><span class=n>n_clusters</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>

<span class=c1># Fit the model to our dataset</span>
<span class=n>kmeans</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>workingdf</span><span class=p>[[</span><span class=s1>&#39;GR&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span> <span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;DTC&#39;</span><span class=p>]])</span>

<span class=c1># Assign the data back to the workingdf</span>
<span class=n>workingdf</span><span class=p>[</span><span class=s1>&#39;KMeans&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>kmeans</span><span class=o>.</span><span class=n>labels_</span>
</code></pre></div><p>To make the comparison simple, we will use the same number of clusters in the Gaussian Mixture Model. For this model the number of clusters parameter is known as n_components.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># Create the gmm model with the selected number of clusters/components</span>
<span class=n>gmm</span> <span class=o>=</span> <span class=n>GaussianMixture</span><span class=p>(</span><span class=n>n_components</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>

<span class=c1># Fit the model to our dataset</span>
<span class=n>gmm</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>workingdf</span><span class=p>[[</span><span class=s1>&#39;GR&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span> <span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;DTC&#39;</span><span class=p>]])</span>

<span class=c1># Predict the labels</span>
<span class=n>gmm_labels</span> <span class=o>=</span> <span class=n>gmm</span><span class=o>.</span><span class=n>predict</span><span class=p>(</span><span class=n>workingdf</span><span class=p>[[</span><span class=s1>&#39;GR&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span> <span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;DTC&#39;</span><span class=p>]])</span>

<span class=c1># Assign the labels back to the workingdf</span>
<span class=n>workingdf</span><span class=p>[</span><span class=s1>&#39;GMM&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>gmm_labels</span>
</code></pre></div><h2 id=plotting-the-results>Plotting the Results</h2><p>Now that the clusters have been computed using KMeans and GMM methods, we can plot the data to see how well the predicted in relation to the labelled lithologies. Note that these methods are unsupervised and do not use the labelled data for training. We are comparing here how well unsupervised methods perform with well log data.</p><p>As we predicted into the main <code>workingdf</code> dataframe, we need to split the data up again into individual wells. We can do this by calling upon the simple function created earlier.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>dfs_wells</span><span class=p>,</span> <span class=n>wellnames</span> <span class=o>=</span> <span class=n>well_splitter</span><span class=p>(</span><span class=n>workingdf</span><span class=p>,</span> <span class=s1>&#39;WELL&#39;</span><span class=p>)</span>
</code></pre></div><pre><code>index  wellname
0      15/9-13
1      15/9-15
2      15/9-17
3      16/1-6 A
4      16/10-1
5      16/10-2
6      16/10-3
7      16/10-5
8      16/2-11 A
9      16/2-16
</code></pre><p>The first plot we will look at is the logplot. We will pass in the original lithofacies (LITH_SI) column and the newly computed KMeans and GMM results.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># Setup the curves to plot</span>
<span class=n>curves_to_plot</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;GR&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span> <span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;DTC&#39;</span><span class=p>,</span>  <span class=s1>&#39;LITH_SI&#39;</span><span class=p>,</span> <span class=s1>&#39;KMeans&#39;</span><span class=p>,</span><span class=s1>&#39;GMM&#39;</span><span class=p>]</span>
<span class=n>logarithmic_curves</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;RDEP&#39;</span><span class=p>]</span>
<span class=n>facies_curve</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;KMeans&#39;</span><span class=p>,</span><span class=s1>&#39;GMM&#39;</span><span class=p>,</span> <span class=s1>&#39;LITH_SI&#39;</span><span class=p>]</span>

<span class=c1># Create plot by passing in the relevant well index number</span>
<span class=n>well</span> <span class=o>=</span> <span class=mi>4</span>
<span class=n>cmap_facies</span> <span class=o>=</span> <span class=n>create_plot</span><span class=p>(</span><span class=n>wellnames</span><span class=p>[</span><span class=n>well</span><span class=p>],</span> 
            <span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>],</span> 
            <span class=n>curves_to_plot</span><span class=p>,</span> 
            <span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;DEPTH_MD&#39;</span><span class=p>],</span> 
            <span class=n>logarithmic_curves</span><span class=p>,</span> <span class=n>facies_curve</span><span class=p>)</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_49_0.png alt=png></p><p>In the plot above we have the original Lithology and our computer KMeans and GMM cluster results in the last three subplots.</p><p>The first thing to note is that the colours do not neccessarily mean the data is from the same group across each method. There are way to map these so that the colouring is consistent, but for the purposes of this tutorial, we will not go into this.</p><p>Looking at well 16/10-1 (index 4), we have 10 separate facies/groups displayed and we can see that these mostly tie up with the changes in the logging measurements. For example the decrease in Gamma Ray (GR) from around 2300m to around 2775m ties in nicely with the blue and light blue grouping. In the KMeans and GMM models, this section has also been highlighted as being in the same cluster in both methods, however, there is no variation in this section. As both of these methods were set to a max of 5 clusters, we will not be able to capture the same degree of variation.</p><p>To resolve this, we could increase the number of clusters.</p><h3 id=viewing-results-on-scatterplots--crossplots>Viewing Results on Scatterplots / Crossplots</h3><p>Another way to view the performance of the clustering is through scatter plots. We can do this using the common density-neutron scatterplots / crossplots and using matplotlib.</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span><span class=mi>10</span><span class=p>))</span>
<span class=n>ax1</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplot2grid</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>))</span>
<span class=n>ax1</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;NPHI&#39;</span><span class=p>],</span> <span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;RHOB&#39;</span><span class=p>],</span> <span class=n>c</span><span class=o>=</span><span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;KMeans&#39;</span><span class=p>],</span> <span class=n>s</span><span class=o>=</span><span class=mi>8</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=n>cmap_facies</span><span class=p>)</span>
<span class=n>ax1</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;KMeans&#39;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>22</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mf>1.05</span><span class=p>)</span>

<span class=n>ax2</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplot2grid</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>))</span>
<span class=n>ax2</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;NPHI&#39;</span><span class=p>],</span> <span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;RHOB&#39;</span><span class=p>],</span> <span class=n>c</span><span class=o>=</span><span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;GMM&#39;</span><span class=p>],</span> <span class=n>s</span><span class=o>=</span><span class=mi>8</span><span class=p>)</span>
<span class=n>ax2</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;GMM&#39;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>22</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mf>1.05</span><span class=p>)</span>

<span class=n>ax3</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplot2grid</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>2</span><span class=p>))</span>
<span class=n>ax3</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;NPHI&#39;</span><span class=p>],</span> <span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;RHOB&#39;</span><span class=p>],</span> <span class=n>c</span><span class=o>=</span><span class=n>dfs_wells</span><span class=p>[</span><span class=n>well</span><span class=p>][</span><span class=s1>&#39;LITH_SI&#39;</span><span class=p>],</span> <span class=n>s</span><span class=o>=</span><span class=mi>8</span><span class=p>)</span>
<span class=n>ax3</span><span class=o>.</span><span class=n>set_title</span><span class=p>(</span><span class=s1>&#39;Lithology (Supplied)&#39;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>22</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mf>1.05</span><span class=p>)</span>

<span class=k>for</span> <span class=n>ax</span> <span class=ow>in</span> <span class=p>[</span><span class=n>ax1</span><span class=p>,</span> <span class=n>ax2</span><span class=p>,</span> <span class=n>ax3</span><span class=p>]:</span>
    <span class=n>ax</span><span class=o>.</span><span class=n>set_xlim</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mf>0.7</span><span class=p>)</span>
    <span class=n>ax</span><span class=o>.</span><span class=n>set_ylim</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mf>1.5</span><span class=p>)</span>
    <span class=n>ax</span><span class=o>.</span><span class=n>set_ylabel</span><span class=p>(</span><span class=s1>&#39;RHOB&#39;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>18</span><span class=p>,</span> <span class=n>labelpad</span><span class=o>=</span><span class=mi>30</span><span class=p>)</span>
    <span class=n>ax</span><span class=o>.</span><span class=n>set_xlabel</span><span class=p>(</span><span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=n>fontsize</span><span class=o>=</span><span class=mi>18</span><span class=p>,</span> <span class=n>labelpad</span><span class=o>=</span><span class=mi>30</span><span class=p>)</span>
    <span class=n>ax</span><span class=o>.</span><span class=n>grid</span><span class=p>()</span>
    <span class=n>ax</span><span class=o>.</span><span class=n>set_axisbelow</span><span class=p>(</span><span class=bp>True</span><span class=p>)</span>

    <span class=n>ax</span><span class=o>.</span><span class=n>tick_params</span><span class=p>(</span><span class=n>axis</span><span class=o>=</span><span class=s1>&#39;both&#39;</span><span class=p>,</span> <span class=n>labelsize</span><span class=o>=</span><span class=mi>14</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>tight_layout</span><span class=p>()</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_52_0.png alt=png></p><p>Even though there is mixing of the clusters in each method, the interval that was discussed in the log plot section can be identified in the lower left of the plot, where we have higher density values and lower neutron porosity values.</p><p>In the KMeans grouping, this cluster shows as one complete cluster, however, in the GMM method we can see it matches closer to the supplied lithology.</p><h3 id=viewing-results-on-a-pairplot>Viewing Results on a Pairplot</h3><p>As we used four input curves for our model, we should look at all of these to see how the clusters vary. The best way to do this is to use the excellent pairplot from the seaborn library. This plot displays the relationships between the data in the dataset on a grid. This allows a quick and easy way to identify and visualise the data. Along the diagonal the distribution of the data split by cluster is also plotted.</p><p>As we are looking at well number 4 we need to pass in that dataframe to the pairplot (dfs_wells[4])</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>sns</span><span class=o>.</span><span class=n>pairplot</span><span class=p>(</span><span class=n>dfs_wells</span><span class=p>[</span><span class=mi>4</span><span class=p>],</span> <span class=nb>vars</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;GR&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span><span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;DTC&#39;</span><span class=p>],</span> <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;KMeans&#39;</span><span class=p>,</span> <span class=n>palette</span><span class=o>=</span><span class=s1>&#39;Dark2&#39;</span><span class=p>,</span>
             <span class=n>diag_kind</span><span class=o>=</span><span class=s1>&#39;kde&#39;</span><span class=p>,</span> <span class=n>plot_kws</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;s&#39;</span><span class=p>:</span> <span class=mi>15</span><span class=p>,</span> <span class=s1>&#39;marker&#39;</span><span class=p>:</span><span class=s1>&#39;o&#39;</span><span class=p>,</span> <span class=s1>&#39;alpha&#39;</span><span class=p>:</span><span class=mi>1</span><span class=p>})</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_54_1.png alt=png></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>sns</span><span class=o>.</span><span class=n>pairplot</span><span class=p>(</span><span class=n>dfs_wells</span><span class=p>[</span><span class=mi>4</span><span class=p>],</span> <span class=nb>vars</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;GR&#39;</span><span class=p>,</span> <span class=s1>&#39;RHOB&#39;</span><span class=p>,</span><span class=s1>&#39;NPHI&#39;</span><span class=p>,</span> <span class=s1>&#39;DTC&#39;</span><span class=p>],</span> <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;GMM&#39;</span><span class=p>,</span> <span class=n>palette</span><span class=o>=</span><span class=s1>&#39;Dark2&#39;</span><span class=p>,</span>
             <span class=n>diag_kind</span><span class=o>=</span><span class=s1>&#39;kde&#39;</span><span class=p>,</span> <span class=n>plot_kws</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;s&#39;</span><span class=p>:</span> <span class=mi>15</span><span class=p>,</span> <span class=s1>&#39;marker&#39;</span><span class=p>:</span><span class=s1>&#39;o&#39;</span><span class=p>,</span> <span class=s1>&#39;alpha&#39;</span><span class=p>:</span><span class=mi>1</span><span class=p>})</span>
</code></pre></div><p><img src=https://www.andymcdonald.scot/images/blog/2021/06/Unsupervised%20Clustering%20for%20Lithofacies_files/output_55_1.png alt=png></p><p>This provides us a much nicer plot to look at and also allows us to see how the data is clustered in the other logging curves. We can see that the GMM model provides some improvement in defining the clusters, especially in the DTC vs RHOB plot.</p><h1 id=summary>Summary</h1><p>In this article we have covered the basics for carrying out unsupervised cluster analysis using two popular algorithms - KMeans Clustering and Gaussian Mixture Modelling. Using an optimisation method we have determined, by eye, that the optimum number of clusters was five, however, it is worth experimenting with more clusters to see if this provides a better match.</p><p>Once the clustering was complete, we saw multiple ways to visualise the results: a standard log plot setup, scatter plots and seaborn&rsquo;s pairplot.</p><p>As K-Means clustering utilises spherical clusters, it may not always be appropriate to well log data and the subsurface. However, Gaussian Mixture Modelling does appear to provide a slight improvement in clustering.</p><p><em><strong>Thanks for reading!</strong></em></p><p><em>If you have found this article useful, please feel free to check out my other articles looking at various aspects of Python and well log data. You can also find my code used in this article and others at <a href=https://github.com/andymcdgeo>GitHub</a>.</em></p><p><em>If you want to get in touch you can find me on <a href=https://www.linkedin.com/in/andymcdonaldgeo/>LinkedIn</a> or at my <a href=http://andymcdonald.scot/>website</a>.</em></p><p><em>Interested in learning more about python and well log data or petrophysics? Follow me on <a href=https://medium.com/@andymcdonaldgeo>Medium</a>.</em></p><p>If you have enjoyed this article or any others and want to show your appreciate you are welcome to <a href=https://www.buymeacoffee.com/andymcdonaldgeo>Buy Me a Coffee</a></p><h1 id=references>References</h1><p>Bormann, Peter, Aursand, Peder, Dilib, Fahad, Manral, Surrender, & Dischington, Peter. (2020). FORCE 2020 Well well log and lithofacies dataset for machine learning competition [Data set]. Zenodo. <a href=http://doi.org/10.5281/zenodo.4351156>http://doi.org/10.5281/zenodo.4351156</a></p></div></article></div></div><div class=row><div class="col-sm-8 col-sm-offset-2"><div id=share><style>#share-buttons{display:inline-block;vertical-align:middle}#share-buttons:after{content:"";display:block;clear:both}#share-buttons>div{position:relative;text-align:left;height:36px;width:32px;float:left;text-align:center}#share-buttons>div>svg{height:16px;fill:#d5d5d5;margin-top:10px}#share-buttons>div:hover{cursor:pointer}#share-buttons>div.facebook:hover>svg{fill:#3b5998}#share-buttons>div.twitter:hover>svg{fill:#55acee}#share-buttons>div.linkedin:hover>svg{fill:#0077b5}#share-buttons>div.pinterest:hover>svg{fill:#cb2027}#share-buttons>div.gplus:hover>svg{fill:#dd4b39}#share-buttons>div.mail:hover>svg{fill:#7d7d7d}#share-buttons>div.instagram:hover>svg{fill:#c73b92}#share-buttons>div.facebook>svg{height:18px;margin-top:9px}#share-buttons>div.twitter>svg{height:20px;margin-top:8px}#share-buttons>div.linkedin>svg{height:19px;margin-top:7px}#share-buttons>div.pinterest>svg{height:20px;margin-top:9px}#share-buttons>div.gplus>svg{height:17px;margin-top:9px;position:relative;left:1px}#share-buttons>div.mail>svg{height:14px;margin-top:11px}</style><span style=color:silver>Share on:</span><div id=share-buttons><div class=facebook title="Share this on Facebook" onclick="window.open('http://www.facebook.com/share.php?u=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/')"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z"/></svg></div><div class=twitter title="Share this on Twitter" onclick="window.open('http://twitter.com/home?status=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/')"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5T1369.5 1125 1185 1335.5t-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5T285 1033q33 5 61 5 43 0 85-11-112-23-185.5-111.5T172 710v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5T884 653q-8-38-8-74 0-134 94.5-228.5T1199 256q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"/></svg></div><div class=linkedin title="Share this on Linkedin" onclick="window.open('https://www.linkedin.com/shareArticle?mini=true&url=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/&title=&summary=&source=')"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z"/></svg></div><div class=gplus title="Share this on Google Plus" onclick="window.open('https://plus.google.com/share?url=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/')"><svg viewBox="0 0 2304 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1437 913q0 208-87 370.5t-248 254-369 91.5q-149 0-285-58t-234-156-156-234T0 896t58-285 156-234 234-156 285-58q286 0 491 192l-199 191Q908 433 733 433q-123 0-227.5 62T340 663.5 279 896t61 232.5T505.5 1297t227.5 62q83 0 152.5-23t114.5-57.5 78.5-78.5 49-83 21.5-74H733V791h692q12 63 12 122zm867-122v210h-209v209h-210v-209h-209V791h209V582h210v209h209z"/></svg></div><div class=mail title="Share this through Email" onclick="window.open('mailto:?&body=https://www.andymcdonald.scot/blog/2021/2021-06-02-unsupervised-clustering-of-facies/')"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47H160q-66 0-113-47T0 1504V710q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 1e2-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38T639 1015q-91-64-262-182.5T172 690q-62-42-117-115.5T0 438q0-78 41.5-130T160 256h1472q65 0 112.5 47t47.5 113z"/></svg></div></div></div></div></div><div class=clearfix></div><div class=row><div class="col-sm-8 col-sm-offset-2"><div id=comments><div id=disqus_thread></div><script>(function(){var a=document,b=a.createElement('script');b.src='https:///embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></div><div class=clearfix></div></div></main><footer id=underfooter><div class=container><div class=row><div class=social-footer><div class=col-md-12><p class=text-center><a href=https://www.linkedin.com/andymcdonaldgeo target=_blank><i class="fab fa-linkedin fa-1x"></i></a>
<a href=https://www.researchgate.net/profile/Andrew-Mcdonald-15 target=_blank><i class="fab fa-researchgate fa-1x"></i></a>
<a href=https://twitter.com/geoandymcd target=_blank><i class="fab fa-twitter-square fa-1x"></i></a>
<a href=https://github.com/andymcdgeo target=_blank><i class="fab fa-github-square fa-1x"></i></a>
<a href=https://andymcdonaldgeo.medium.com target=_blank><i class="fab fa-medium fa-1x"></i></a></p></div></div></div><div class=row><div class=col-md-12><div class=widget-body><p class=text-center>Copyright &copy; 2021, Andy McDonald<br>Powered by: <a href=https://gohugo.io/ rel=poweredby>Hugo</a></p></div></div></div></div></footer><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script src=https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.0/jquery.waypoints.min.js></script><script src=https://www.andymcdonald.scot/js/bundle.min.00e4b79049366199ff1b6ac7cbd8302877370d1bf4ff0db6be4c4190e2e43f9143709df60bd35ed5c6f6495ad18afc509d468b7be1665c90f32b62afa4c7114c.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-DWZLFXGHNF"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-DWZLFXGHNF')</script></body></html></body></html>